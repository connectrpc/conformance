// Copyright 2022-2023 The Connect Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: connectrpc/conformance/v1/messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_connectrpc_2fconformance_2fv1_2fmessages_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_connectrpc_2fconformance_2fv1_2fmessages_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/wrappers.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_connectrpc_2fconformance_2fv1_2fmessages_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
namespace connectrpc {
namespace conformance {
namespace v1 {
class ClientConfigureRequest;
struct ClientConfigureRequestDefaultTypeInternal;
extern ClientConfigureRequestDefaultTypeInternal _ClientConfigureRequest_default_instance_;
class ClientConfigureRequest_Metadata;
struct ClientConfigureRequest_MetadataDefaultTypeInternal;
extern ClientConfigureRequest_MetadataDefaultTypeInternal _ClientConfigureRequest_Metadata_default_instance_;
class ClientConfigureResponse;
struct ClientConfigureResponseDefaultTypeInternal;
extern ClientConfigureResponseDefaultTypeInternal _ClientConfigureResponse_default_instance_;
class EchoStatus;
struct EchoStatusDefaultTypeInternal;
extern EchoStatusDefaultTypeInternal _EchoStatus_default_instance_;
class ErrorDetail;
struct ErrorDetailDefaultTypeInternal;
extern ErrorDetailDefaultTypeInternal _ErrorDetail_default_instance_;
class ErrorStatus;
struct ErrorStatusDefaultTypeInternal;
extern ErrorStatusDefaultTypeInternal _ErrorStatus_default_instance_;
class LoadBalancerAccumulatedStatsRequest;
struct LoadBalancerAccumulatedStatsRequestDefaultTypeInternal;
extern LoadBalancerAccumulatedStatsRequestDefaultTypeInternal _LoadBalancerAccumulatedStatsRequest_default_instance_;
class LoadBalancerAccumulatedStatsResponse;
struct LoadBalancerAccumulatedStatsResponseDefaultTypeInternal;
extern LoadBalancerAccumulatedStatsResponseDefaultTypeInternal _LoadBalancerAccumulatedStatsResponse_default_instance_;
class LoadBalancerAccumulatedStatsResponse_MethodStats;
struct LoadBalancerAccumulatedStatsResponse_MethodStatsDefaultTypeInternal;
extern LoadBalancerAccumulatedStatsResponse_MethodStatsDefaultTypeInternal _LoadBalancerAccumulatedStatsResponse_MethodStats_default_instance_;
class LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse;
struct LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUseDefaultTypeInternal;
extern LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUseDefaultTypeInternal _LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse_default_instance_;
class LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse;
struct LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUseDefaultTypeInternal;
extern LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUseDefaultTypeInternal _LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse_default_instance_;
class LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse;
struct LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUseDefaultTypeInternal;
extern LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUseDefaultTypeInternal _LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse_default_instance_;
class LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse;
struct LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUseDefaultTypeInternal;
extern LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUseDefaultTypeInternal _LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse_default_instance_;
class LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse;
struct LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUseDefaultTypeInternal;
extern LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUseDefaultTypeInternal _LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse_default_instance_;
class LoadBalancerStatsRequest;
struct LoadBalancerStatsRequestDefaultTypeInternal;
extern LoadBalancerStatsRequestDefaultTypeInternal _LoadBalancerStatsRequest_default_instance_;
class LoadBalancerStatsResponse;
struct LoadBalancerStatsResponseDefaultTypeInternal;
extern LoadBalancerStatsResponseDefaultTypeInternal _LoadBalancerStatsResponse_default_instance_;
class LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse;
struct LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUseDefaultTypeInternal;
extern LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUseDefaultTypeInternal _LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse_default_instance_;
class LoadBalancerStatsResponse_RpcsByPeer;
struct LoadBalancerStatsResponse_RpcsByPeerDefaultTypeInternal;
extern LoadBalancerStatsResponse_RpcsByPeerDefaultTypeInternal _LoadBalancerStatsResponse_RpcsByPeer_default_instance_;
class LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse;
struct LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUseDefaultTypeInternal;
extern LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUseDefaultTypeInternal _LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse_default_instance_;
class LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse;
struct LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUseDefaultTypeInternal;
extern LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUseDefaultTypeInternal _LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse_default_instance_;
class Payload;
struct PayloadDefaultTypeInternal;
extern PayloadDefaultTypeInternal _Payload_default_instance_;
class ReconnectInfo;
struct ReconnectInfoDefaultTypeInternal;
extern ReconnectInfoDefaultTypeInternal _ReconnectInfo_default_instance_;
class ReconnectParams;
struct ReconnectParamsDefaultTypeInternal;
extern ReconnectParamsDefaultTypeInternal _ReconnectParams_default_instance_;
class ResponseParameters;
struct ResponseParametersDefaultTypeInternal;
extern ResponseParametersDefaultTypeInternal _ResponseParameters_default_instance_;
class SimpleRequest;
struct SimpleRequestDefaultTypeInternal;
extern SimpleRequestDefaultTypeInternal _SimpleRequest_default_instance_;
class SimpleResponse;
struct SimpleResponseDefaultTypeInternal;
extern SimpleResponseDefaultTypeInternal _SimpleResponse_default_instance_;
class StreamingInputCallRequest;
struct StreamingInputCallRequestDefaultTypeInternal;
extern StreamingInputCallRequestDefaultTypeInternal _StreamingInputCallRequest_default_instance_;
class StreamingInputCallResponse;
struct StreamingInputCallResponseDefaultTypeInternal;
extern StreamingInputCallResponseDefaultTypeInternal _StreamingInputCallResponse_default_instance_;
class StreamingOutputCallRequest;
struct StreamingOutputCallRequestDefaultTypeInternal;
extern StreamingOutputCallRequestDefaultTypeInternal _StreamingOutputCallRequest_default_instance_;
class StreamingOutputCallResponse;
struct StreamingOutputCallResponseDefaultTypeInternal;
extern StreamingOutputCallResponseDefaultTypeInternal _StreamingOutputCallResponse_default_instance_;
}  // namespace v1
}  // namespace conformance
}  // namespace connectrpc
PROTOBUF_NAMESPACE_OPEN
template <>
::connectrpc::conformance::v1::ClientConfigureRequest* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::ClientConfigureRequest>(Arena*);
template <>
::connectrpc::conformance::v1::ClientConfigureRequest_Metadata* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::ClientConfigureRequest_Metadata>(Arena*);
template <>
::connectrpc::conformance::v1::ClientConfigureResponse* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::ClientConfigureResponse>(Arena*);
template <>
::connectrpc::conformance::v1::EchoStatus* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::EchoStatus>(Arena*);
template <>
::connectrpc::conformance::v1::ErrorDetail* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::ErrorDetail>(Arena*);
template <>
::connectrpc::conformance::v1::ErrorStatus* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::ErrorStatus>(Arena*);
template <>
::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsRequest* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsRequest>(Arena*);
template <>
::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse>(Arena*);
template <>
::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats>(Arena*);
template <>
::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse>(Arena*);
template <>
::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse>(Arena*);
template <>
::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse>(Arena*);
template <>
::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse>(Arena*);
template <>
::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse>(Arena*);
template <>
::connectrpc::conformance::v1::LoadBalancerStatsRequest* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::LoadBalancerStatsRequest>(Arena*);
template <>
::connectrpc::conformance::v1::LoadBalancerStatsResponse* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::LoadBalancerStatsResponse>(Arena*);
template <>
::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse>(Arena*);
template <>
::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer>(Arena*);
template <>
::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse>(Arena*);
template <>
::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse>(Arena*);
template <>
::connectrpc::conformance::v1::Payload* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::Payload>(Arena*);
template <>
::connectrpc::conformance::v1::ReconnectInfo* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::ReconnectInfo>(Arena*);
template <>
::connectrpc::conformance::v1::ReconnectParams* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::ReconnectParams>(Arena*);
template <>
::connectrpc::conformance::v1::ResponseParameters* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::ResponseParameters>(Arena*);
template <>
::connectrpc::conformance::v1::SimpleRequest* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::SimpleRequest>(Arena*);
template <>
::connectrpc::conformance::v1::SimpleResponse* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::SimpleResponse>(Arena*);
template <>
::connectrpc::conformance::v1::StreamingInputCallRequest* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::StreamingInputCallRequest>(Arena*);
template <>
::connectrpc::conformance::v1::StreamingInputCallResponse* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::StreamingInputCallResponse>(Arena*);
template <>
::connectrpc::conformance::v1::StreamingOutputCallRequest* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::StreamingOutputCallRequest>(Arena*);
template <>
::connectrpc::conformance::v1::StreamingOutputCallResponse* Arena::CreateMaybeMessage<::connectrpc::conformance::v1::StreamingOutputCallResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace connectrpc {
namespace conformance {
namespace v1 {
enum ClientConfigureRequest_RpcType : int {
  ClientConfigureRequest_RpcType_EMPTY_CALL = 0,
  ClientConfigureRequest_RpcType_UNARY_CALL = 1,
  ClientConfigureRequest_RpcType_ClientConfigureRequest_RpcType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ClientConfigureRequest_RpcType_ClientConfigureRequest_RpcType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ClientConfigureRequest_RpcType_IsValid(int value);
constexpr ClientConfigureRequest_RpcType ClientConfigureRequest_RpcType_RpcType_MIN = static_cast<ClientConfigureRequest_RpcType>(0);
constexpr ClientConfigureRequest_RpcType ClientConfigureRequest_RpcType_RpcType_MAX = static_cast<ClientConfigureRequest_RpcType>(1);
constexpr int ClientConfigureRequest_RpcType_RpcType_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ClientConfigureRequest_RpcType_descriptor();
template <typename T>
const std::string& ClientConfigureRequest_RpcType_Name(T value) {
  static_assert(std::is_same<T, ClientConfigureRequest_RpcType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RpcType_Name().");
  return ClientConfigureRequest_RpcType_Name(static_cast<ClientConfigureRequest_RpcType>(value));
}
template <>
inline const std::string& ClientConfigureRequest_RpcType_Name(ClientConfigureRequest_RpcType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ClientConfigureRequest_RpcType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ClientConfigureRequest_RpcType_Parse(absl::string_view name, ClientConfigureRequest_RpcType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientConfigureRequest_RpcType>(
      ClientConfigureRequest_RpcType_descriptor(), name, value);
}
enum PayloadType : int {
  COMPRESSABLE = 0,
  PayloadType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PayloadType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PayloadType_IsValid(int value);
constexpr PayloadType PayloadType_MIN = static_cast<PayloadType>(0);
constexpr PayloadType PayloadType_MAX = static_cast<PayloadType>(0);
constexpr int PayloadType_ARRAYSIZE = 0 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
PayloadType_descriptor();
template <typename T>
const std::string& PayloadType_Name(T value) {
  static_assert(std::is_same<T, PayloadType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PayloadType_Name().");
  return PayloadType_Name(static_cast<PayloadType>(value));
}
template <>
inline const std::string& PayloadType_Name(PayloadType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<PayloadType_descriptor,
                                                 0, 0>(
      static_cast<int>(value));
}
inline bool PayloadType_Parse(absl::string_view name, PayloadType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PayloadType>(
      PayloadType_descriptor(), name, value);
}
enum GrpclbRouteType : int {
  GRPCLB_ROUTE_TYPE_UNKNOWN = 0,
  GRPCLB_ROUTE_TYPE_FALLBACK = 1,
  GRPCLB_ROUTE_TYPE_BACKEND = 2,
  GrpclbRouteType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GrpclbRouteType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GrpclbRouteType_IsValid(int value);
constexpr GrpclbRouteType GrpclbRouteType_MIN = static_cast<GrpclbRouteType>(0);
constexpr GrpclbRouteType GrpclbRouteType_MAX = static_cast<GrpclbRouteType>(2);
constexpr int GrpclbRouteType_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
GrpclbRouteType_descriptor();
template <typename T>
const std::string& GrpclbRouteType_Name(T value) {
  static_assert(std::is_same<T, GrpclbRouteType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GrpclbRouteType_Name().");
  return GrpclbRouteType_Name(static_cast<GrpclbRouteType>(value));
}
template <>
inline const std::string& GrpclbRouteType_Name(GrpclbRouteType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<GrpclbRouteType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool GrpclbRouteType_Parse(absl::string_view name, GrpclbRouteType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GrpclbRouteType>(
      GrpclbRouteType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Payload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.Payload) */ {
 public:
  inline Payload() : Payload(nullptr) {}
  ~Payload() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Payload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Payload(const Payload& from);
  Payload(Payload&& from) noexcept
    : Payload() {
    *this = ::std::move(from);
  }

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payload& operator=(Payload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Payload& default_instance() {
    return *internal_default_instance();
  }
  static inline const Payload* internal_default_instance() {
    return reinterpret_cast<const Payload*>(
               &_Payload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Payload& a, Payload& b) {
    a.Swap(&b);
  }
  inline void Swap(Payload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Payload* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Payload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Payload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Payload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Payload& from) {
    Payload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.Payload";
  }
  protected:
  explicit Payload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodyFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes body = 2 [json_name = "body"];
  void clear_body() ;
  const std::string& body() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* ptr);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // .connectrpc.conformance.v1.PayloadType type = 1 [json_name = "type"];
  void clear_type() ;
  ::connectrpc::conformance::v1::PayloadType type() const;
  void set_type(::connectrpc::conformance::v1::PayloadType value);

  private:
  ::connectrpc::conformance::v1::PayloadType _internal_type() const;
  void _internal_set_type(::connectrpc::conformance::v1::PayloadType value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.Payload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class EchoStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.EchoStatus) */ {
 public:
  inline EchoStatus() : EchoStatus(nullptr) {}
  ~EchoStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EchoStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EchoStatus(const EchoStatus& from);
  EchoStatus(EchoStatus&& from) noexcept
    : EchoStatus() {
    *this = ::std::move(from);
  }

  inline EchoStatus& operator=(const EchoStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline EchoStatus& operator=(EchoStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EchoStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const EchoStatus* internal_default_instance() {
    return reinterpret_cast<const EchoStatus*>(
               &_EchoStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EchoStatus& a, EchoStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(EchoStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EchoStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EchoStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EchoStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EchoStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EchoStatus& from) {
    EchoStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EchoStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.EchoStatus";
  }
  protected:
  explicit EchoStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2 [json_name = "message"];
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // int32 code = 1 [json_name = "code"];
  void clear_code() ;
  ::int32_t code() const;
  void set_code(::int32_t value);

  private:
  ::int32_t _internal_code() const;
  void _internal_set_code(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.EchoStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class SimpleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.SimpleRequest) */ {
 public:
  inline SimpleRequest() : SimpleRequest(nullptr) {}
  ~SimpleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SimpleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimpleRequest(const SimpleRequest& from);
  SimpleRequest(SimpleRequest&& from) noexcept
    : SimpleRequest() {
    *this = ::std::move(from);
  }

  inline SimpleRequest& operator=(const SimpleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimpleRequest& operator=(SimpleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimpleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimpleRequest* internal_default_instance() {
    return reinterpret_cast<const SimpleRequest*>(
               &_SimpleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SimpleRequest& a, SimpleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SimpleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimpleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimpleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimpleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimpleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SimpleRequest& from) {
    SimpleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimpleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.SimpleRequest";
  }
  protected:
  explicit SimpleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 3,
    kResponseCompressedFieldNumber = 6,
    kResponseStatusFieldNumber = 7,
    kExpectCompressedFieldNumber = 8,
    kResponseTypeFieldNumber = 1,
    kResponseSizeFieldNumber = 2,
    kFillUsernameFieldNumber = 4,
    kFillOauthScopeFieldNumber = 5,
    kFillServerIdFieldNumber = 9,
    kFillGrpclbRouteTypeFieldNumber = 10,
  };
  // .connectrpc.conformance.v1.Payload payload = 3 [json_name = "payload"];
  bool has_payload() const;
  void clear_payload() ;
  const ::connectrpc::conformance::v1::Payload& payload() const;
  PROTOBUF_NODISCARD ::connectrpc::conformance::v1::Payload* release_payload();
  ::connectrpc::conformance::v1::Payload* mutable_payload();
  void set_allocated_payload(::connectrpc::conformance::v1::Payload* payload);
  private:
  const ::connectrpc::conformance::v1::Payload& _internal_payload() const;
  ::connectrpc::conformance::v1::Payload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::connectrpc::conformance::v1::Payload* payload);
  ::connectrpc::conformance::v1::Payload* unsafe_arena_release_payload();
  // .google.protobuf.BoolValue response_compressed = 6 [json_name = "responseCompressed"];
  bool has_response_compressed() const;
  void clear_response_compressed() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& response_compressed() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_response_compressed();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_response_compressed();
  void set_allocated_response_compressed(::PROTOBUF_NAMESPACE_ID::BoolValue* response_compressed);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_response_compressed() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_response_compressed();
  public:
  void unsafe_arena_set_allocated_response_compressed(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* response_compressed);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_response_compressed();
  // .connectrpc.conformance.v1.EchoStatus response_status = 7 [json_name = "responseStatus"];
  bool has_response_status() const;
  void clear_response_status() ;
  const ::connectrpc::conformance::v1::EchoStatus& response_status() const;
  PROTOBUF_NODISCARD ::connectrpc::conformance::v1::EchoStatus* release_response_status();
  ::connectrpc::conformance::v1::EchoStatus* mutable_response_status();
  void set_allocated_response_status(::connectrpc::conformance::v1::EchoStatus* response_status);
  private:
  const ::connectrpc::conformance::v1::EchoStatus& _internal_response_status() const;
  ::connectrpc::conformance::v1::EchoStatus* _internal_mutable_response_status();
  public:
  void unsafe_arena_set_allocated_response_status(
      ::connectrpc::conformance::v1::EchoStatus* response_status);
  ::connectrpc::conformance::v1::EchoStatus* unsafe_arena_release_response_status();
  // .google.protobuf.BoolValue expect_compressed = 8 [json_name = "expectCompressed"];
  bool has_expect_compressed() const;
  void clear_expect_compressed() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& expect_compressed() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_expect_compressed();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_expect_compressed();
  void set_allocated_expect_compressed(::PROTOBUF_NAMESPACE_ID::BoolValue* expect_compressed);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_expect_compressed() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_expect_compressed();
  public:
  void unsafe_arena_set_allocated_expect_compressed(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* expect_compressed);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_expect_compressed();
  // .connectrpc.conformance.v1.PayloadType response_type = 1 [json_name = "responseType"];
  void clear_response_type() ;
  ::connectrpc::conformance::v1::PayloadType response_type() const;
  void set_response_type(::connectrpc::conformance::v1::PayloadType value);

  private:
  ::connectrpc::conformance::v1::PayloadType _internal_response_type() const;
  void _internal_set_response_type(::connectrpc::conformance::v1::PayloadType value);

  public:
  // int32 response_size = 2 [json_name = "responseSize"];
  void clear_response_size() ;
  ::int32_t response_size() const;
  void set_response_size(::int32_t value);

  private:
  ::int32_t _internal_response_size() const;
  void _internal_set_response_size(::int32_t value);

  public:
  // bool fill_username = 4 [json_name = "fillUsername"];
  void clear_fill_username() ;
  bool fill_username() const;
  void set_fill_username(bool value);

  private:
  bool _internal_fill_username() const;
  void _internal_set_fill_username(bool value);

  public:
  // bool fill_oauth_scope = 5 [json_name = "fillOauthScope"];
  void clear_fill_oauth_scope() ;
  bool fill_oauth_scope() const;
  void set_fill_oauth_scope(bool value);

  private:
  bool _internal_fill_oauth_scope() const;
  void _internal_set_fill_oauth_scope(bool value);

  public:
  // bool fill_server_id = 9 [json_name = "fillServerId"];
  void clear_fill_server_id() ;
  bool fill_server_id() const;
  void set_fill_server_id(bool value);

  private:
  bool _internal_fill_server_id() const;
  void _internal_set_fill_server_id(bool value);

  public:
  // bool fill_grpclb_route_type = 10 [json_name = "fillGrpclbRouteType"];
  void clear_fill_grpclb_route_type() ;
  bool fill_grpclb_route_type() const;
  void set_fill_grpclb_route_type(bool value);

  private:
  bool _internal_fill_grpclb_route_type() const;
  void _internal_set_fill_grpclb_route_type(bool value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.SimpleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::connectrpc::conformance::v1::Payload* payload_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* response_compressed_;
    ::connectrpc::conformance::v1::EchoStatus* response_status_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* expect_compressed_;
    int response_type_;
    ::int32_t response_size_;
    bool fill_username_;
    bool fill_oauth_scope_;
    bool fill_server_id_;
    bool fill_grpclb_route_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class SimpleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.SimpleResponse) */ {
 public:
  inline SimpleResponse() : SimpleResponse(nullptr) {}
  ~SimpleResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SimpleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimpleResponse(const SimpleResponse& from);
  SimpleResponse(SimpleResponse&& from) noexcept
    : SimpleResponse() {
    *this = ::std::move(from);
  }

  inline SimpleResponse& operator=(const SimpleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimpleResponse& operator=(SimpleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimpleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimpleResponse* internal_default_instance() {
    return reinterpret_cast<const SimpleResponse*>(
               &_SimpleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SimpleResponse& a, SimpleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SimpleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimpleResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimpleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimpleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimpleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SimpleResponse& from) {
    SimpleResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimpleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.SimpleResponse";
  }
  protected:
  explicit SimpleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kOauthScopeFieldNumber = 3,
    kServerIdFieldNumber = 4,
    kHostnameFieldNumber = 6,
    kPayloadFieldNumber = 1,
    kGrpclbRouteTypeFieldNumber = 5,
  };
  // string username = 2 [json_name = "username"];
  void clear_username() ;
  const std::string& username() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* ptr);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string oauth_scope = 3 [json_name = "oauthScope"];
  void clear_oauth_scope() ;
  const std::string& oauth_scope() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oauth_scope(Arg_&& arg, Args_... args);
  std::string* mutable_oauth_scope();
  PROTOBUF_NODISCARD std::string* release_oauth_scope();
  void set_allocated_oauth_scope(std::string* ptr);

  private:
  const std::string& _internal_oauth_scope() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oauth_scope(
      const std::string& value);
  std::string* _internal_mutable_oauth_scope();

  public:
  // string server_id = 4 [json_name = "serverId"];
  void clear_server_id() ;
  const std::string& server_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_id(Arg_&& arg, Args_... args);
  std::string* mutable_server_id();
  PROTOBUF_NODISCARD std::string* release_server_id();
  void set_allocated_server_id(std::string* ptr);

  private:
  const std::string& _internal_server_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_id(
      const std::string& value);
  std::string* _internal_mutable_server_id();

  public:
  // string hostname = 6 [json_name = "hostname"];
  void clear_hostname() ;
  const std::string& hostname() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hostname(Arg_&& arg, Args_... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* ptr);

  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(
      const std::string& value);
  std::string* _internal_mutable_hostname();

  public:
  // .connectrpc.conformance.v1.Payload payload = 1 [json_name = "payload"];
  bool has_payload() const;
  void clear_payload() ;
  const ::connectrpc::conformance::v1::Payload& payload() const;
  PROTOBUF_NODISCARD ::connectrpc::conformance::v1::Payload* release_payload();
  ::connectrpc::conformance::v1::Payload* mutable_payload();
  void set_allocated_payload(::connectrpc::conformance::v1::Payload* payload);
  private:
  const ::connectrpc::conformance::v1::Payload& _internal_payload() const;
  ::connectrpc::conformance::v1::Payload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::connectrpc::conformance::v1::Payload* payload);
  ::connectrpc::conformance::v1::Payload* unsafe_arena_release_payload();
  // .connectrpc.conformance.v1.GrpclbRouteType grpclb_route_type = 5 [json_name = "grpclbRouteType"];
  void clear_grpclb_route_type() ;
  ::connectrpc::conformance::v1::GrpclbRouteType grpclb_route_type() const;
  void set_grpclb_route_type(::connectrpc::conformance::v1::GrpclbRouteType value);

  private:
  ::connectrpc::conformance::v1::GrpclbRouteType _internal_grpclb_route_type() const;
  void _internal_set_grpclb_route_type(::connectrpc::conformance::v1::GrpclbRouteType value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.SimpleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oauth_scope_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::connectrpc::conformance::v1::Payload* payload_;
    int grpclb_route_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class StreamingInputCallRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.StreamingInputCallRequest) */ {
 public:
  inline StreamingInputCallRequest() : StreamingInputCallRequest(nullptr) {}
  ~StreamingInputCallRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamingInputCallRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamingInputCallRequest(const StreamingInputCallRequest& from);
  StreamingInputCallRequest(StreamingInputCallRequest&& from) noexcept
    : StreamingInputCallRequest() {
    *this = ::std::move(from);
  }

  inline StreamingInputCallRequest& operator=(const StreamingInputCallRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingInputCallRequest& operator=(StreamingInputCallRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingInputCallRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamingInputCallRequest* internal_default_instance() {
    return reinterpret_cast<const StreamingInputCallRequest*>(
               &_StreamingInputCallRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StreamingInputCallRequest& a, StreamingInputCallRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingInputCallRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingInputCallRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingInputCallRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingInputCallRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamingInputCallRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamingInputCallRequest& from) {
    StreamingInputCallRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamingInputCallRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.StreamingInputCallRequest";
  }
  protected:
  explicit StreamingInputCallRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
    kExpectCompressedFieldNumber = 2,
  };
  // .connectrpc.conformance.v1.Payload payload = 1 [json_name = "payload"];
  bool has_payload() const;
  void clear_payload() ;
  const ::connectrpc::conformance::v1::Payload& payload() const;
  PROTOBUF_NODISCARD ::connectrpc::conformance::v1::Payload* release_payload();
  ::connectrpc::conformance::v1::Payload* mutable_payload();
  void set_allocated_payload(::connectrpc::conformance::v1::Payload* payload);
  private:
  const ::connectrpc::conformance::v1::Payload& _internal_payload() const;
  ::connectrpc::conformance::v1::Payload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::connectrpc::conformance::v1::Payload* payload);
  ::connectrpc::conformance::v1::Payload* unsafe_arena_release_payload();
  // .google.protobuf.BoolValue expect_compressed = 2 [json_name = "expectCompressed"];
  bool has_expect_compressed() const;
  void clear_expect_compressed() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& expect_compressed() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_expect_compressed();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_expect_compressed();
  void set_allocated_expect_compressed(::PROTOBUF_NAMESPACE_ID::BoolValue* expect_compressed);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_expect_compressed() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_expect_compressed();
  public:
  void unsafe_arena_set_allocated_expect_compressed(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* expect_compressed);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_expect_compressed();
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.StreamingInputCallRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::connectrpc::conformance::v1::Payload* payload_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* expect_compressed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class StreamingInputCallResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.StreamingInputCallResponse) */ {
 public:
  inline StreamingInputCallResponse() : StreamingInputCallResponse(nullptr) {}
  ~StreamingInputCallResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamingInputCallResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamingInputCallResponse(const StreamingInputCallResponse& from);
  StreamingInputCallResponse(StreamingInputCallResponse&& from) noexcept
    : StreamingInputCallResponse() {
    *this = ::std::move(from);
  }

  inline StreamingInputCallResponse& operator=(const StreamingInputCallResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingInputCallResponse& operator=(StreamingInputCallResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingInputCallResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamingInputCallResponse* internal_default_instance() {
    return reinterpret_cast<const StreamingInputCallResponse*>(
               &_StreamingInputCallResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StreamingInputCallResponse& a, StreamingInputCallResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingInputCallResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingInputCallResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingInputCallResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingInputCallResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamingInputCallResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamingInputCallResponse& from) {
    StreamingInputCallResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamingInputCallResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.StreamingInputCallResponse";
  }
  protected:
  explicit StreamingInputCallResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAggregatedPayloadSizeFieldNumber = 1,
  };
  // int32 aggregated_payload_size = 1 [json_name = "aggregatedPayloadSize"];
  void clear_aggregated_payload_size() ;
  ::int32_t aggregated_payload_size() const;
  void set_aggregated_payload_size(::int32_t value);

  private:
  ::int32_t _internal_aggregated_payload_size() const;
  void _internal_set_aggregated_payload_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.StreamingInputCallResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t aggregated_payload_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class ResponseParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.ResponseParameters) */ {
 public:
  inline ResponseParameters() : ResponseParameters(nullptr) {}
  ~ResponseParameters() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseParameters(const ResponseParameters& from);
  ResponseParameters(ResponseParameters&& from) noexcept
    : ResponseParameters() {
    *this = ::std::move(from);
  }

  inline ResponseParameters& operator=(const ResponseParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseParameters& operator=(ResponseParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseParameters* internal_default_instance() {
    return reinterpret_cast<const ResponseParameters*>(
               &_ResponseParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ResponseParameters& a, ResponseParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseParameters* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseParameters& from) {
    ResponseParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.ResponseParameters";
  }
  protected:
  explicit ResponseParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompressedFieldNumber = 3,
    kSizeFieldNumber = 1,
    kIntervalUsFieldNumber = 2,
  };
  // .google.protobuf.BoolValue compressed = 3 [json_name = "compressed"];
  bool has_compressed() const;
  void clear_compressed() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& compressed() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_compressed();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_compressed();
  void set_allocated_compressed(::PROTOBUF_NAMESPACE_ID::BoolValue* compressed);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_compressed() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_compressed();
  public:
  void unsafe_arena_set_allocated_compressed(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* compressed);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_compressed();
  // int32 size = 1 [json_name = "size"];
  void clear_size() ;
  ::int32_t size() const;
  void set_size(::int32_t value);

  private:
  ::int32_t _internal_size() const;
  void _internal_set_size(::int32_t value);

  public:
  // int32 interval_us = 2 [json_name = "intervalUs"];
  void clear_interval_us() ;
  ::int32_t interval_us() const;
  void set_interval_us(::int32_t value);

  private:
  ::int32_t _internal_interval_us() const;
  void _internal_set_interval_us(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.ResponseParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* compressed_;
    ::int32_t size_;
    ::int32_t interval_us_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class StreamingOutputCallRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.StreamingOutputCallRequest) */ {
 public:
  inline StreamingOutputCallRequest() : StreamingOutputCallRequest(nullptr) {}
  ~StreamingOutputCallRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamingOutputCallRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamingOutputCallRequest(const StreamingOutputCallRequest& from);
  StreamingOutputCallRequest(StreamingOutputCallRequest&& from) noexcept
    : StreamingOutputCallRequest() {
    *this = ::std::move(from);
  }

  inline StreamingOutputCallRequest& operator=(const StreamingOutputCallRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingOutputCallRequest& operator=(StreamingOutputCallRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingOutputCallRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamingOutputCallRequest* internal_default_instance() {
    return reinterpret_cast<const StreamingOutputCallRequest*>(
               &_StreamingOutputCallRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StreamingOutputCallRequest& a, StreamingOutputCallRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingOutputCallRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingOutputCallRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingOutputCallRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingOutputCallRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamingOutputCallRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamingOutputCallRequest& from) {
    StreamingOutputCallRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamingOutputCallRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.StreamingOutputCallRequest";
  }
  protected:
  explicit StreamingOutputCallRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseParametersFieldNumber = 2,
    kPayloadFieldNumber = 3,
    kResponseStatusFieldNumber = 7,
    kResponseTypeFieldNumber = 1,
  };
  // repeated .connectrpc.conformance.v1.ResponseParameters response_parameters = 2 [json_name = "responseParameters"];
  int response_parameters_size() const;
  private:
  int _internal_response_parameters_size() const;

  public:
  void clear_response_parameters() ;
  ::connectrpc::conformance::v1::ResponseParameters* mutable_response_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::connectrpc::conformance::v1::ResponseParameters >*
      mutable_response_parameters();
  private:
  const ::connectrpc::conformance::v1::ResponseParameters& _internal_response_parameters(int index) const;
  ::connectrpc::conformance::v1::ResponseParameters* _internal_add_response_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::connectrpc::conformance::v1::ResponseParameters>& _internal_response_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::connectrpc::conformance::v1::ResponseParameters>* _internal_mutable_response_parameters();
  public:
  const ::connectrpc::conformance::v1::ResponseParameters& response_parameters(int index) const;
  ::connectrpc::conformance::v1::ResponseParameters* add_response_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::connectrpc::conformance::v1::ResponseParameters >&
      response_parameters() const;
  // .connectrpc.conformance.v1.Payload payload = 3 [json_name = "payload"];
  bool has_payload() const;
  void clear_payload() ;
  const ::connectrpc::conformance::v1::Payload& payload() const;
  PROTOBUF_NODISCARD ::connectrpc::conformance::v1::Payload* release_payload();
  ::connectrpc::conformance::v1::Payload* mutable_payload();
  void set_allocated_payload(::connectrpc::conformance::v1::Payload* payload);
  private:
  const ::connectrpc::conformance::v1::Payload& _internal_payload() const;
  ::connectrpc::conformance::v1::Payload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::connectrpc::conformance::v1::Payload* payload);
  ::connectrpc::conformance::v1::Payload* unsafe_arena_release_payload();
  // .connectrpc.conformance.v1.EchoStatus response_status = 7 [json_name = "responseStatus"];
  bool has_response_status() const;
  void clear_response_status() ;
  const ::connectrpc::conformance::v1::EchoStatus& response_status() const;
  PROTOBUF_NODISCARD ::connectrpc::conformance::v1::EchoStatus* release_response_status();
  ::connectrpc::conformance::v1::EchoStatus* mutable_response_status();
  void set_allocated_response_status(::connectrpc::conformance::v1::EchoStatus* response_status);
  private:
  const ::connectrpc::conformance::v1::EchoStatus& _internal_response_status() const;
  ::connectrpc::conformance::v1::EchoStatus* _internal_mutable_response_status();
  public:
  void unsafe_arena_set_allocated_response_status(
      ::connectrpc::conformance::v1::EchoStatus* response_status);
  ::connectrpc::conformance::v1::EchoStatus* unsafe_arena_release_response_status();
  // .connectrpc.conformance.v1.PayloadType response_type = 1 [json_name = "responseType"];
  void clear_response_type() ;
  ::connectrpc::conformance::v1::PayloadType response_type() const;
  void set_response_type(::connectrpc::conformance::v1::PayloadType value);

  private:
  ::connectrpc::conformance::v1::PayloadType _internal_response_type() const;
  void _internal_set_response_type(::connectrpc::conformance::v1::PayloadType value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.StreamingOutputCallRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::connectrpc::conformance::v1::ResponseParameters > response_parameters_;
    ::connectrpc::conformance::v1::Payload* payload_;
    ::connectrpc::conformance::v1::EchoStatus* response_status_;
    int response_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class StreamingOutputCallResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.StreamingOutputCallResponse) */ {
 public:
  inline StreamingOutputCallResponse() : StreamingOutputCallResponse(nullptr) {}
  ~StreamingOutputCallResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamingOutputCallResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamingOutputCallResponse(const StreamingOutputCallResponse& from);
  StreamingOutputCallResponse(StreamingOutputCallResponse&& from) noexcept
    : StreamingOutputCallResponse() {
    *this = ::std::move(from);
  }

  inline StreamingOutputCallResponse& operator=(const StreamingOutputCallResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingOutputCallResponse& operator=(StreamingOutputCallResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingOutputCallResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamingOutputCallResponse* internal_default_instance() {
    return reinterpret_cast<const StreamingOutputCallResponse*>(
               &_StreamingOutputCallResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StreamingOutputCallResponse& a, StreamingOutputCallResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingOutputCallResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingOutputCallResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingOutputCallResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingOutputCallResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamingOutputCallResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamingOutputCallResponse& from) {
    StreamingOutputCallResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamingOutputCallResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.StreamingOutputCallResponse";
  }
  protected:
  explicit StreamingOutputCallResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
  };
  // .connectrpc.conformance.v1.Payload payload = 1 [json_name = "payload"];
  bool has_payload() const;
  void clear_payload() ;
  const ::connectrpc::conformance::v1::Payload& payload() const;
  PROTOBUF_NODISCARD ::connectrpc::conformance::v1::Payload* release_payload();
  ::connectrpc::conformance::v1::Payload* mutable_payload();
  void set_allocated_payload(::connectrpc::conformance::v1::Payload* payload);
  private:
  const ::connectrpc::conformance::v1::Payload& _internal_payload() const;
  ::connectrpc::conformance::v1::Payload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::connectrpc::conformance::v1::Payload* payload);
  ::connectrpc::conformance::v1::Payload* unsafe_arena_release_payload();
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.StreamingOutputCallResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::connectrpc::conformance::v1::Payload* payload_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class ReconnectParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.ReconnectParams) */ {
 public:
  inline ReconnectParams() : ReconnectParams(nullptr) {}
  ~ReconnectParams() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ReconnectParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReconnectParams(const ReconnectParams& from);
  ReconnectParams(ReconnectParams&& from) noexcept
    : ReconnectParams() {
    *this = ::std::move(from);
  }

  inline ReconnectParams& operator=(const ReconnectParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReconnectParams& operator=(ReconnectParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReconnectParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReconnectParams* internal_default_instance() {
    return reinterpret_cast<const ReconnectParams*>(
               &_ReconnectParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReconnectParams& a, ReconnectParams& b) {
    a.Swap(&b);
  }
  inline void Swap(ReconnectParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReconnectParams* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReconnectParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReconnectParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReconnectParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReconnectParams& from) {
    ReconnectParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReconnectParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.ReconnectParams";
  }
  protected:
  explicit ReconnectParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxReconnectBackoffMsFieldNumber = 1,
  };
  // int32 max_reconnect_backoff_ms = 1 [json_name = "maxReconnectBackoffMs"];
  void clear_max_reconnect_backoff_ms() ;
  ::int32_t max_reconnect_backoff_ms() const;
  void set_max_reconnect_backoff_ms(::int32_t value);

  private:
  ::int32_t _internal_max_reconnect_backoff_ms() const;
  void _internal_set_max_reconnect_backoff_ms(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.ReconnectParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t max_reconnect_backoff_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class ReconnectInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.ReconnectInfo) */ {
 public:
  inline ReconnectInfo() : ReconnectInfo(nullptr) {}
  ~ReconnectInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ReconnectInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReconnectInfo(const ReconnectInfo& from);
  ReconnectInfo(ReconnectInfo&& from) noexcept
    : ReconnectInfo() {
    *this = ::std::move(from);
  }

  inline ReconnectInfo& operator=(const ReconnectInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReconnectInfo& operator=(ReconnectInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReconnectInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReconnectInfo* internal_default_instance() {
    return reinterpret_cast<const ReconnectInfo*>(
               &_ReconnectInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ReconnectInfo& a, ReconnectInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ReconnectInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReconnectInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReconnectInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReconnectInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReconnectInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReconnectInfo& from) {
    ReconnectInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReconnectInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.ReconnectInfo";
  }
  protected:
  explicit ReconnectInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBackoffMsFieldNumber = 2,
    kPassedFieldNumber = 1,
  };
  // repeated int32 backoff_ms = 2 [json_name = "backoffMs"];
  int backoff_ms_size() const;
  private:
  int _internal_backoff_ms_size() const;

  public:
  void clear_backoff_ms() ;
  ::int32_t backoff_ms(int index) const;
  void set_backoff_ms(int index, ::int32_t value);
  void add_backoff_ms(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& backoff_ms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* mutable_backoff_ms();

  private:
  ::int32_t _internal_backoff_ms(int index) const;
  void _internal_add_backoff_ms(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& _internal_backoff_ms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* _internal_mutable_backoff_ms();

  public:
  // bool passed = 1 [json_name = "passed"];
  void clear_passed() ;
  bool passed() const;
  void set_passed(bool value);

  private:
  bool _internal_passed() const;
  void _internal_set_passed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.ReconnectInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t> backoff_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _backoff_ms_cached_byte_size_;
    bool passed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class LoadBalancerStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.LoadBalancerStatsRequest) */ {
 public:
  inline LoadBalancerStatsRequest() : LoadBalancerStatsRequest(nullptr) {}
  ~LoadBalancerStatsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadBalancerStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadBalancerStatsRequest(const LoadBalancerStatsRequest& from);
  LoadBalancerStatsRequest(LoadBalancerStatsRequest&& from) noexcept
    : LoadBalancerStatsRequest() {
    *this = ::std::move(from);
  }

  inline LoadBalancerStatsRequest& operator=(const LoadBalancerStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadBalancerStatsRequest& operator=(LoadBalancerStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadBalancerStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadBalancerStatsRequest* internal_default_instance() {
    return reinterpret_cast<const LoadBalancerStatsRequest*>(
               &_LoadBalancerStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LoadBalancerStatsRequest& a, LoadBalancerStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadBalancerStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadBalancerStatsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadBalancerStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadBalancerStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadBalancerStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadBalancerStatsRequest& from) {
    LoadBalancerStatsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadBalancerStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.LoadBalancerStatsRequest";
  }
  protected:
  explicit LoadBalancerStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumRpcsFieldNumber = 1,
    kTimeoutSecFieldNumber = 2,
  };
  // int32 num_rpcs = 1 [json_name = "numRpcs"];
  void clear_num_rpcs() ;
  ::int32_t num_rpcs() const;
  void set_num_rpcs(::int32_t value);

  private:
  ::int32_t _internal_num_rpcs() const;
  void _internal_set_num_rpcs(::int32_t value);

  public:
  // int32 timeout_sec = 2 [json_name = "timeoutSec"];
  void clear_timeout_sec() ;
  ::int32_t timeout_sec() const;
  void set_timeout_sec(::int32_t value);

  private:
  ::int32_t _internal_timeout_sec() const;
  void _internal_set_timeout_sec(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.LoadBalancerStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t num_rpcs_;
    ::int32_t timeout_sec_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse, 
    std::string, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse, 
    std::string, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse& other);
  static const LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse*>(&_LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "connectrpc.conformance.v1.LoadBalancerStatsResponse.RpcsByPeer.RpcsByPeerEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class LoadBalancerStatsResponse_RpcsByPeer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.LoadBalancerStatsResponse.RpcsByPeer) */ {
 public:
  inline LoadBalancerStatsResponse_RpcsByPeer() : LoadBalancerStatsResponse_RpcsByPeer(nullptr) {}
  ~LoadBalancerStatsResponse_RpcsByPeer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadBalancerStatsResponse_RpcsByPeer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadBalancerStatsResponse_RpcsByPeer(const LoadBalancerStatsResponse_RpcsByPeer& from);
  LoadBalancerStatsResponse_RpcsByPeer(LoadBalancerStatsResponse_RpcsByPeer&& from) noexcept
    : LoadBalancerStatsResponse_RpcsByPeer() {
    *this = ::std::move(from);
  }

  inline LoadBalancerStatsResponse_RpcsByPeer& operator=(const LoadBalancerStatsResponse_RpcsByPeer& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadBalancerStatsResponse_RpcsByPeer& operator=(LoadBalancerStatsResponse_RpcsByPeer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadBalancerStatsResponse_RpcsByPeer& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadBalancerStatsResponse_RpcsByPeer* internal_default_instance() {
    return reinterpret_cast<const LoadBalancerStatsResponse_RpcsByPeer*>(
               &_LoadBalancerStatsResponse_RpcsByPeer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(LoadBalancerStatsResponse_RpcsByPeer& a, LoadBalancerStatsResponse_RpcsByPeer& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadBalancerStatsResponse_RpcsByPeer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadBalancerStatsResponse_RpcsByPeer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadBalancerStatsResponse_RpcsByPeer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadBalancerStatsResponse_RpcsByPeer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadBalancerStatsResponse_RpcsByPeer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadBalancerStatsResponse_RpcsByPeer& from) {
    LoadBalancerStatsResponse_RpcsByPeer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadBalancerStatsResponse_RpcsByPeer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.LoadBalancerStatsResponse.RpcsByPeer";
  }
  protected:
  explicit LoadBalancerStatsResponse_RpcsByPeer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRpcsByPeerFieldNumber = 1,
  };
  // map<string, int32> rpcs_by_peer = 1 [json_name = "rpcsByPeer"];
  int rpcs_by_peer_size() const;
  private:
  int _internal_rpcs_by_peer_size() const;

  public:
  void clear_rpcs_by_peer() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
      _internal_rpcs_by_peer() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
      _internal_mutable_rpcs_by_peer();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
      rpcs_by_peer() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
      mutable_rpcs_by_peer();
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.LoadBalancerStatsResponse.RpcsByPeer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LoadBalancerStatsResponse_RpcsByPeer_RpcsByPeerEntry_DoNotUse,
        std::string, ::int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> rpcs_by_peer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse, 
    std::string, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse, 
    std::string, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse& other);
  static const LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse*>(&_LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "connectrpc.conformance.v1.LoadBalancerStatsResponse.RpcsByPeerEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse, 
    std::string, ::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse, 
    std::string, ::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse& other);
  static const LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse*>(&_LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "connectrpc.conformance.v1.LoadBalancerStatsResponse.RpcsByMethodEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class LoadBalancerStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.LoadBalancerStatsResponse) */ {
 public:
  inline LoadBalancerStatsResponse() : LoadBalancerStatsResponse(nullptr) {}
  ~LoadBalancerStatsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadBalancerStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadBalancerStatsResponse(const LoadBalancerStatsResponse& from);
  LoadBalancerStatsResponse(LoadBalancerStatsResponse&& from) noexcept
    : LoadBalancerStatsResponse() {
    *this = ::std::move(from);
  }

  inline LoadBalancerStatsResponse& operator=(const LoadBalancerStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadBalancerStatsResponse& operator=(LoadBalancerStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadBalancerStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadBalancerStatsResponse* internal_default_instance() {
    return reinterpret_cast<const LoadBalancerStatsResponse*>(
               &_LoadBalancerStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LoadBalancerStatsResponse& a, LoadBalancerStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadBalancerStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadBalancerStatsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadBalancerStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadBalancerStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadBalancerStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadBalancerStatsResponse& from) {
    LoadBalancerStatsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadBalancerStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.LoadBalancerStatsResponse";
  }
  protected:
  explicit LoadBalancerStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LoadBalancerStatsResponse_RpcsByPeer RpcsByPeer;

  // accessors -------------------------------------------------------

  enum : int {
    kRpcsByPeerFieldNumber = 1,
    kRpcsByMethodFieldNumber = 3,
    kNumFailuresFieldNumber = 2,
  };
  // map<string, int32> rpcs_by_peer = 1 [json_name = "rpcsByPeer"];
  int rpcs_by_peer_size() const;
  private:
  int _internal_rpcs_by_peer_size() const;

  public:
  void clear_rpcs_by_peer() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
      _internal_rpcs_by_peer() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
      _internal_mutable_rpcs_by_peer();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
      rpcs_by_peer() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
      mutable_rpcs_by_peer();
  // map<string, .connectrpc.conformance.v1.LoadBalancerStatsResponse.RpcsByPeer> rpcs_by_method = 3 [json_name = "rpcsByMethod"];
  int rpcs_by_method_size() const;
  private:
  int _internal_rpcs_by_method_size() const;

  public:
  void clear_rpcs_by_method() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer >&
      _internal_rpcs_by_method() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer >*
      _internal_mutable_rpcs_by_method();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer >&
      rpcs_by_method() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer >*
      mutable_rpcs_by_method();
  // int32 num_failures = 2 [json_name = "numFailures"];
  void clear_num_failures() ;
  ::int32_t num_failures() const;
  void set_num_failures(::int32_t value);

  private:
  ::int32_t _internal_num_failures() const;
  void _internal_set_num_failures(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.LoadBalancerStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LoadBalancerStatsResponse_RpcsByPeerEntry_DoNotUse,
        std::string, ::int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> rpcs_by_peer_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LoadBalancerStatsResponse_RpcsByMethodEntry_DoNotUse,
        std::string, ::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> rpcs_by_method_;
    ::int32_t num_failures_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class LoadBalancerAccumulatedStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsRequest) */ {
 public:
  inline LoadBalancerAccumulatedStatsRequest() : LoadBalancerAccumulatedStatsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadBalancerAccumulatedStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadBalancerAccumulatedStatsRequest(const LoadBalancerAccumulatedStatsRequest& from);
  LoadBalancerAccumulatedStatsRequest(LoadBalancerAccumulatedStatsRequest&& from) noexcept
    : LoadBalancerAccumulatedStatsRequest() {
    *this = ::std::move(from);
  }

  inline LoadBalancerAccumulatedStatsRequest& operator=(const LoadBalancerAccumulatedStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadBalancerAccumulatedStatsRequest& operator=(LoadBalancerAccumulatedStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadBalancerAccumulatedStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadBalancerAccumulatedStatsRequest* internal_default_instance() {
    return reinterpret_cast<const LoadBalancerAccumulatedStatsRequest*>(
               &_LoadBalancerAccumulatedStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(LoadBalancerAccumulatedStatsRequest& a, LoadBalancerAccumulatedStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadBalancerAccumulatedStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadBalancerAccumulatedStatsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadBalancerAccumulatedStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadBalancerAccumulatedStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LoadBalancerAccumulatedStatsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LoadBalancerAccumulatedStatsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.LoadBalancerAccumulatedStatsRequest";
  }
  protected:
  explicit LoadBalancerAccumulatedStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse, 
    std::string, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse, 
    std::string, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse& other);
  static const LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse*>(&_LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.NumRpcsStartedByMethodEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse, 
    std::string, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse, 
    std::string, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse& other);
  static const LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse*>(&_LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.NumRpcsSucceededByMethodEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse, 
    std::string, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse, 
    std::string, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse& other);
  static const LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse*>(&_LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.NumRpcsFailedByMethodEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse, 
    ::int32_t, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse& other);
  static const LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse*>(&_LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class LoadBalancerAccumulatedStatsResponse_MethodStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.MethodStats) */ {
 public:
  inline LoadBalancerAccumulatedStatsResponse_MethodStats() : LoadBalancerAccumulatedStatsResponse_MethodStats(nullptr) {}
  ~LoadBalancerAccumulatedStatsResponse_MethodStats() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadBalancerAccumulatedStatsResponse_MethodStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadBalancerAccumulatedStatsResponse_MethodStats(const LoadBalancerAccumulatedStatsResponse_MethodStats& from);
  LoadBalancerAccumulatedStatsResponse_MethodStats(LoadBalancerAccumulatedStatsResponse_MethodStats&& from) noexcept
    : LoadBalancerAccumulatedStatsResponse_MethodStats() {
    *this = ::std::move(from);
  }

  inline LoadBalancerAccumulatedStatsResponse_MethodStats& operator=(const LoadBalancerAccumulatedStatsResponse_MethodStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadBalancerAccumulatedStatsResponse_MethodStats& operator=(LoadBalancerAccumulatedStatsResponse_MethodStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadBalancerAccumulatedStatsResponse_MethodStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadBalancerAccumulatedStatsResponse_MethodStats* internal_default_instance() {
    return reinterpret_cast<const LoadBalancerAccumulatedStatsResponse_MethodStats*>(
               &_LoadBalancerAccumulatedStatsResponse_MethodStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(LoadBalancerAccumulatedStatsResponse_MethodStats& a, LoadBalancerAccumulatedStatsResponse_MethodStats& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadBalancerAccumulatedStatsResponse_MethodStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadBalancerAccumulatedStatsResponse_MethodStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadBalancerAccumulatedStatsResponse_MethodStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadBalancerAccumulatedStatsResponse_MethodStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadBalancerAccumulatedStatsResponse_MethodStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadBalancerAccumulatedStatsResponse_MethodStats& from) {
    LoadBalancerAccumulatedStatsResponse_MethodStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadBalancerAccumulatedStatsResponse_MethodStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.MethodStats";
  }
  protected:
  explicit LoadBalancerAccumulatedStatsResponse_MethodStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kRpcsStartedFieldNumber = 1,
  };
  // map<int32, int32> result = 2 [json_name = "result"];
  int result_size() const;
  private:
  int _internal_result_size() const;

  public:
  void clear_result() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::int32_t >&
      _internal_result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::int32_t >*
      _internal_mutable_result();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::int32_t >&
      result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::int32_t >*
      mutable_result();
  // int32 rpcs_started = 1 [json_name = "rpcsStarted"];
  void clear_rpcs_started() ;
  ::int32_t rpcs_started() const;
  void set_rpcs_started(::int32_t value);

  private:
  ::int32_t _internal_rpcs_started() const;
  void _internal_set_rpcs_started(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.MethodStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LoadBalancerAccumulatedStatsResponse_MethodStats_ResultEntry_DoNotUse,
        ::int32_t, ::int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> result_;
    ::int32_t rpcs_started_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse, 
    std::string, ::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse, 
    std::string, ::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse& other);
  static const LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse*>(&_LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.StatsPerMethodEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class LoadBalancerAccumulatedStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse) */ {
 public:
  inline LoadBalancerAccumulatedStatsResponse() : LoadBalancerAccumulatedStatsResponse(nullptr) {}
  ~LoadBalancerAccumulatedStatsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadBalancerAccumulatedStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadBalancerAccumulatedStatsResponse(const LoadBalancerAccumulatedStatsResponse& from);
  LoadBalancerAccumulatedStatsResponse(LoadBalancerAccumulatedStatsResponse&& from) noexcept
    : LoadBalancerAccumulatedStatsResponse() {
    *this = ::std::move(from);
  }

  inline LoadBalancerAccumulatedStatsResponse& operator=(const LoadBalancerAccumulatedStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadBalancerAccumulatedStatsResponse& operator=(LoadBalancerAccumulatedStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadBalancerAccumulatedStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadBalancerAccumulatedStatsResponse* internal_default_instance() {
    return reinterpret_cast<const LoadBalancerAccumulatedStatsResponse*>(
               &_LoadBalancerAccumulatedStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(LoadBalancerAccumulatedStatsResponse& a, LoadBalancerAccumulatedStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadBalancerAccumulatedStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadBalancerAccumulatedStatsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadBalancerAccumulatedStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadBalancerAccumulatedStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadBalancerAccumulatedStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadBalancerAccumulatedStatsResponse& from) {
    LoadBalancerAccumulatedStatsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadBalancerAccumulatedStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse";
  }
  protected:
  explicit LoadBalancerAccumulatedStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LoadBalancerAccumulatedStatsResponse_MethodStats MethodStats;

  // accessors -------------------------------------------------------

  enum : int {
    kNumRpcsStartedByMethodFieldNumber = 1,
    kNumRpcsSucceededByMethodFieldNumber = 2,
    kNumRpcsFailedByMethodFieldNumber = 3,
    kStatsPerMethodFieldNumber = 4,
  };
  // map<string, int32> num_rpcs_started_by_method = 1 [json_name = "numRpcsStartedByMethod", deprecated = true];
  [[deprecated]]  int num_rpcs_started_by_method_size() const;
  private:
  int _internal_num_rpcs_started_by_method_size() const;

  public:
  [[deprecated]]  void clear_num_rpcs_started_by_method() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
      _internal_num_rpcs_started_by_method() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
      _internal_mutable_num_rpcs_started_by_method();
  public:
  [[deprecated]] const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
      num_rpcs_started_by_method() const;
  [[deprecated]] ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
      mutable_num_rpcs_started_by_method();
  // map<string, int32> num_rpcs_succeeded_by_method = 2 [json_name = "numRpcsSucceededByMethod", deprecated = true];
  [[deprecated]]  int num_rpcs_succeeded_by_method_size() const;
  private:
  int _internal_num_rpcs_succeeded_by_method_size() const;

  public:
  [[deprecated]]  void clear_num_rpcs_succeeded_by_method() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
      _internal_num_rpcs_succeeded_by_method() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
      _internal_mutable_num_rpcs_succeeded_by_method();
  public:
  [[deprecated]] const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
      num_rpcs_succeeded_by_method() const;
  [[deprecated]] ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
      mutable_num_rpcs_succeeded_by_method();
  // map<string, int32> num_rpcs_failed_by_method = 3 [json_name = "numRpcsFailedByMethod", deprecated = true];
  [[deprecated]]  int num_rpcs_failed_by_method_size() const;
  private:
  int _internal_num_rpcs_failed_by_method_size() const;

  public:
  [[deprecated]]  void clear_num_rpcs_failed_by_method() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
      _internal_num_rpcs_failed_by_method() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
      _internal_mutable_num_rpcs_failed_by_method();
  public:
  [[deprecated]] const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
      num_rpcs_failed_by_method() const;
  [[deprecated]] ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
      mutable_num_rpcs_failed_by_method();
  // map<string, .connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.MethodStats> stats_per_method = 4 [json_name = "statsPerMethod"];
  int stats_per_method_size() const;
  private:
  int _internal_stats_per_method_size() const;

  public:
  void clear_stats_per_method() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats >&
      _internal_stats_per_method() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats >*
      _internal_mutable_stats_per_method();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats >&
      stats_per_method() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats >*
      mutable_stats_per_method();
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LoadBalancerAccumulatedStatsResponse_NumRpcsStartedByMethodEntry_DoNotUse,
        std::string, ::int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> num_rpcs_started_by_method_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LoadBalancerAccumulatedStatsResponse_NumRpcsSucceededByMethodEntry_DoNotUse,
        std::string, ::int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> num_rpcs_succeeded_by_method_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LoadBalancerAccumulatedStatsResponse_NumRpcsFailedByMethodEntry_DoNotUse,
        std::string, ::int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> num_rpcs_failed_by_method_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LoadBalancerAccumulatedStatsResponse_StatsPerMethodEntry_DoNotUse,
        std::string, ::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> stats_per_method_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class ClientConfigureRequest_Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.ClientConfigureRequest.Metadata) */ {
 public:
  inline ClientConfigureRequest_Metadata() : ClientConfigureRequest_Metadata(nullptr) {}
  ~ClientConfigureRequest_Metadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClientConfigureRequest_Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientConfigureRequest_Metadata(const ClientConfigureRequest_Metadata& from);
  ClientConfigureRequest_Metadata(ClientConfigureRequest_Metadata&& from) noexcept
    : ClientConfigureRequest_Metadata() {
    *this = ::std::move(from);
  }

  inline ClientConfigureRequest_Metadata& operator=(const ClientConfigureRequest_Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientConfigureRequest_Metadata& operator=(ClientConfigureRequest_Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientConfigureRequest_Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientConfigureRequest_Metadata* internal_default_instance() {
    return reinterpret_cast<const ClientConfigureRequest_Metadata*>(
               &_ClientConfigureRequest_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ClientConfigureRequest_Metadata& a, ClientConfigureRequest_Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientConfigureRequest_Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientConfigureRequest_Metadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientConfigureRequest_Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientConfigureRequest_Metadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientConfigureRequest_Metadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientConfigureRequest_Metadata& from) {
    ClientConfigureRequest_Metadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientConfigureRequest_Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.ClientConfigureRequest.Metadata";
  }
  protected:
  explicit ClientConfigureRequest_Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kValueFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // string key = 2 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // string value = 3 [json_name = "value"];
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .connectrpc.conformance.v1.ClientConfigureRequest.RpcType type = 1 [json_name = "type"];
  void clear_type() ;
  ::connectrpc::conformance::v1::ClientConfigureRequest_RpcType type() const;
  void set_type(::connectrpc::conformance::v1::ClientConfigureRequest_RpcType value);

  private:
  ::connectrpc::conformance::v1::ClientConfigureRequest_RpcType _internal_type() const;
  void _internal_set_type(::connectrpc::conformance::v1::ClientConfigureRequest_RpcType value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.ClientConfigureRequest.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class ClientConfigureRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.ClientConfigureRequest) */ {
 public:
  inline ClientConfigureRequest() : ClientConfigureRequest(nullptr) {}
  ~ClientConfigureRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClientConfigureRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientConfigureRequest(const ClientConfigureRequest& from);
  ClientConfigureRequest(ClientConfigureRequest&& from) noexcept
    : ClientConfigureRequest() {
    *this = ::std::move(from);
  }

  inline ClientConfigureRequest& operator=(const ClientConfigureRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientConfigureRequest& operator=(ClientConfigureRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientConfigureRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientConfigureRequest* internal_default_instance() {
    return reinterpret_cast<const ClientConfigureRequest*>(
               &_ClientConfigureRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ClientConfigureRequest& a, ClientConfigureRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientConfigureRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientConfigureRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientConfigureRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientConfigureRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientConfigureRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientConfigureRequest& from) {
    ClientConfigureRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientConfigureRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.ClientConfigureRequest";
  }
  protected:
  explicit ClientConfigureRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClientConfigureRequest_Metadata Metadata;

  using RpcType = ClientConfigureRequest_RpcType;
  static constexpr RpcType EMPTY_CALL = ClientConfigureRequest_RpcType_EMPTY_CALL;
  static constexpr RpcType UNARY_CALL = ClientConfigureRequest_RpcType_UNARY_CALL;
  static inline bool RpcType_IsValid(int value) {
    return ClientConfigureRequest_RpcType_IsValid(value);
  }
  static constexpr RpcType RpcType_MIN = ClientConfigureRequest_RpcType_RpcType_MIN;
  static constexpr RpcType RpcType_MAX = ClientConfigureRequest_RpcType_RpcType_MAX;
  static constexpr int RpcType_ARRAYSIZE = ClientConfigureRequest_RpcType_RpcType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RpcType_descriptor() {
    return ClientConfigureRequest_RpcType_descriptor();
  }
  template <typename T>
  static inline const std::string& RpcType_Name(T value) {
    return ClientConfigureRequest_RpcType_Name(value);
  }
  static inline bool RpcType_Parse(absl::string_view name, RpcType* value) {
    return ClientConfigureRequest_RpcType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 1,
    kMetadataFieldNumber = 2,
    kTimeoutSecFieldNumber = 3,
  };
  // repeated .connectrpc.conformance.v1.ClientConfigureRequest.RpcType types = 1 [json_name = "types"];
  int types_size() const;
  private:
  int _internal_types_size() const;

  public:
  void clear_types() ;
  public:
  ::connectrpc::conformance::v1::ClientConfigureRequest_RpcType types(int index) const;
  void set_types(int index, ::connectrpc::conformance::v1::ClientConfigureRequest_RpcType value);
  void add_types(::connectrpc::conformance::v1::ClientConfigureRequest_RpcType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_types();

  private:
  ::connectrpc::conformance::v1::ClientConfigureRequest_RpcType _internal_types(int index) const;
  void _internal_add_types(::connectrpc::conformance::v1::ClientConfigureRequest_RpcType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& _internal_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_types();

  public:
  // repeated .connectrpc.conformance.v1.ClientConfigureRequest.Metadata metadata = 2 [json_name = "metadata"];
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata* mutable_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata >*
      mutable_metadata();
  private:
  const ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata& _internal_metadata(int index) const;
  ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata* _internal_add_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::connectrpc::conformance::v1::ClientConfigureRequest_Metadata>& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::connectrpc::conformance::v1::ClientConfigureRequest_Metadata>* _internal_mutable_metadata();
  public:
  const ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata& metadata(int index) const;
  ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata* add_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata >&
      metadata() const;
  // int32 timeout_sec = 3 [json_name = "timeoutSec"];
  void clear_timeout_sec() ;
  ::int32_t timeout_sec() const;
  void set_timeout_sec(::int32_t value);

  private:
  ::int32_t _internal_timeout_sec() const;
  void _internal_set_timeout_sec(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.ClientConfigureRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> types_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _types_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata > metadata_;
    ::int32_t timeout_sec_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class ClientConfigureResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.ClientConfigureResponse) */ {
 public:
  inline ClientConfigureResponse() : ClientConfigureResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClientConfigureResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientConfigureResponse(const ClientConfigureResponse& from);
  ClientConfigureResponse(ClientConfigureResponse&& from) noexcept
    : ClientConfigureResponse() {
    *this = ::std::move(from);
  }

  inline ClientConfigureResponse& operator=(const ClientConfigureResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientConfigureResponse& operator=(ClientConfigureResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientConfigureResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientConfigureResponse* internal_default_instance() {
    return reinterpret_cast<const ClientConfigureResponse*>(
               &_ClientConfigureResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ClientConfigureResponse& a, ClientConfigureResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientConfigureResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientConfigureResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientConfigureResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientConfigureResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ClientConfigureResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ClientConfigureResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.ClientConfigureResponse";
  }
  protected:
  explicit ClientConfigureResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.ClientConfigureResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class ErrorDetail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.ErrorDetail) */ {
 public:
  inline ErrorDetail() : ErrorDetail(nullptr) {}
  ~ErrorDetail() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorDetail(const ErrorDetail& from);
  ErrorDetail(ErrorDetail&& from) noexcept
    : ErrorDetail() {
    *this = ::std::move(from);
  }

  inline ErrorDetail& operator=(const ErrorDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorDetail& operator=(ErrorDetail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorDetail* internal_default_instance() {
    return reinterpret_cast<const ErrorDetail*>(
               &_ErrorDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ErrorDetail& a, ErrorDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorDetail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorDetail* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorDetail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorDetail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ErrorDetail& from) {
    ErrorDetail::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorDetail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.ErrorDetail";
  }
  protected:
  explicit ErrorDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
    kDomainFieldNumber = 2,
  };
  // string reason = 1 [json_name = "reason"];
  void clear_reason() ;
  const std::string& reason() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* ptr);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // string domain = 2 [json_name = "domain"];
  void clear_domain() ;
  const std::string& domain() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_domain(Arg_&& arg, Args_... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* ptr);

  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(
      const std::string& value);
  std::string* _internal_mutable_domain();

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.ErrorDetail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};// -------------------------------------------------------------------

class ErrorStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:connectrpc.conformance.v1.ErrorStatus) */ {
 public:
  inline ErrorStatus() : ErrorStatus(nullptr) {}
  ~ErrorStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorStatus(const ErrorStatus& from);
  ErrorStatus(ErrorStatus&& from) noexcept
    : ErrorStatus() {
    *this = ::std::move(from);
  }

  inline ErrorStatus& operator=(const ErrorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorStatus& operator=(ErrorStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorStatus* internal_default_instance() {
    return reinterpret_cast<const ErrorStatus*>(
               &_ErrorStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ErrorStatus& a, ErrorStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ErrorStatus& from) {
    ErrorStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "connectrpc.conformance.v1.ErrorStatus";
  }
  protected:
  explicit ErrorStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailsFieldNumber = 3,
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // repeated .google.protobuf.Any details = 3 [json_name = "details"];
  int details_size() const;
  private:
  int _internal_details_size() const;

  public:
  void clear_details() ;
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_details(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_details();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_details(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_add_details();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::PROTOBUF_NAMESPACE_ID::Any>& _internal_details() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::PROTOBUF_NAMESPACE_ID::Any>* _internal_mutable_details();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Any& details(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* add_details();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
      details() const;
  // string message = 2 [json_name = "message"];
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // int32 code = 1 [json_name = "code"];
  void clear_code() ;
  ::int32_t code() const;
  void set_code(::int32_t value);

  private:
  ::int32_t _internal_code() const;
  void _internal_set_code(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:connectrpc.conformance.v1.ErrorStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any > details_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connectrpc_2fconformance_2fv1_2fmessages_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Payload

// .connectrpc.conformance.v1.PayloadType type = 1 [json_name = "type"];
inline void Payload::clear_type() {
  _impl_.type_ = 0;
}
inline ::connectrpc::conformance::v1::PayloadType Payload::type() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.Payload.type)
  return _internal_type();
}
inline void Payload::set_type(::connectrpc::conformance::v1::PayloadType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.Payload.type)
}
inline ::connectrpc::conformance::v1::PayloadType Payload::_internal_type() const {
  return static_cast<::connectrpc::conformance::v1::PayloadType>(_impl_.type_);
}
inline void Payload::_internal_set_type(::connectrpc::conformance::v1::PayloadType value) {
  ;
  _impl_.type_ = value;
}

// bytes body = 2 [json_name = "body"];
inline void Payload::clear_body() {
  _impl_.body_.ClearToEmpty();
}
inline const std::string& Payload::body() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.Payload.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Payload::set_body(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.Payload.body)
}
inline std::string* Payload::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.Payload.body)
  return _s;
}
inline const std::string& Payload::_internal_body() const {
  return _impl_.body_.Get();
}
inline void Payload::_internal_set_body(const std::string& value) {
  ;


  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* Payload::_internal_mutable_body() {
  ;
  return _impl_.body_.Mutable( GetArenaForAllocation());
}
inline std::string* Payload::release_body() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.Payload.body)
  return _impl_.body_.Release();
}
inline void Payload::set_allocated_body(std::string* value) {
  _impl_.body_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.body_.IsDefault()) {
          _impl_.body_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.Payload.body)
}

// -------------------------------------------------------------------

// EchoStatus

// int32 code = 1 [json_name = "code"];
inline void EchoStatus::clear_code() {
  _impl_.code_ = 0;
}
inline ::int32_t EchoStatus::code() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.EchoStatus.code)
  return _internal_code();
}
inline void EchoStatus::set_code(::int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.EchoStatus.code)
}
inline ::int32_t EchoStatus::_internal_code() const {
  return _impl_.code_;
}
inline void EchoStatus::_internal_set_code(::int32_t value) {
  ;
  _impl_.code_ = value;
}

// string message = 2 [json_name = "message"];
inline void EchoStatus::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& EchoStatus::message() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.EchoStatus.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EchoStatus::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.EchoStatus.message)
}
inline std::string* EchoStatus::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.EchoStatus.message)
  return _s;
}
inline const std::string& EchoStatus::_internal_message() const {
  return _impl_.message_.Get();
}
inline void EchoStatus::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* EchoStatus::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* EchoStatus::release_message() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.EchoStatus.message)
  return _impl_.message_.Release();
}
inline void EchoStatus::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.EchoStatus.message)
}

// -------------------------------------------------------------------

// SimpleRequest

// .connectrpc.conformance.v1.PayloadType response_type = 1 [json_name = "responseType"];
inline void SimpleRequest::clear_response_type() {
  _impl_.response_type_ = 0;
}
inline ::connectrpc::conformance::v1::PayloadType SimpleRequest::response_type() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleRequest.response_type)
  return _internal_response_type();
}
inline void SimpleRequest::set_response_type(::connectrpc::conformance::v1::PayloadType value) {
   _internal_set_response_type(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.SimpleRequest.response_type)
}
inline ::connectrpc::conformance::v1::PayloadType SimpleRequest::_internal_response_type() const {
  return static_cast<::connectrpc::conformance::v1::PayloadType>(_impl_.response_type_);
}
inline void SimpleRequest::_internal_set_response_type(::connectrpc::conformance::v1::PayloadType value) {
  ;
  _impl_.response_type_ = value;
}

// int32 response_size = 2 [json_name = "responseSize"];
inline void SimpleRequest::clear_response_size() {
  _impl_.response_size_ = 0;
}
inline ::int32_t SimpleRequest::response_size() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleRequest.response_size)
  return _internal_response_size();
}
inline void SimpleRequest::set_response_size(::int32_t value) {
  _internal_set_response_size(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.SimpleRequest.response_size)
}
inline ::int32_t SimpleRequest::_internal_response_size() const {
  return _impl_.response_size_;
}
inline void SimpleRequest::_internal_set_response_size(::int32_t value) {
  ;
  _impl_.response_size_ = value;
}

// .connectrpc.conformance.v1.Payload payload = 3 [json_name = "payload"];
inline bool SimpleRequest::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline void SimpleRequest::clear_payload() {
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::connectrpc::conformance::v1::Payload& SimpleRequest::_internal_payload() const {
  const ::connectrpc::conformance::v1::Payload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::connectrpc::conformance::v1::Payload&>(
      ::connectrpc::conformance::v1::_Payload_default_instance_);
}
inline const ::connectrpc::conformance::v1::Payload& SimpleRequest::payload() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleRequest.payload)
  return _internal_payload();
}
inline void SimpleRequest::unsafe_arena_set_allocated_payload(
    ::connectrpc::conformance::v1::Payload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:connectrpc.conformance.v1.SimpleRequest.payload)
}
inline ::connectrpc::conformance::v1::Payload* SimpleRequest::release_payload() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::connectrpc::conformance::v1::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::connectrpc::conformance::v1::Payload* SimpleRequest::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.SimpleRequest.payload)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::connectrpc::conformance::v1::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::connectrpc::conformance::v1::Payload* SimpleRequest::_internal_mutable_payload() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::connectrpc::conformance::v1::Payload>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::connectrpc::conformance::v1::Payload* SimpleRequest::mutable_payload() {
  ::connectrpc::conformance::v1::Payload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.SimpleRequest.payload)
  return _msg;
}
inline void SimpleRequest::set_allocated_payload(::connectrpc::conformance::v1::Payload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.SimpleRequest.payload)
}

// bool fill_username = 4 [json_name = "fillUsername"];
inline void SimpleRequest::clear_fill_username() {
  _impl_.fill_username_ = false;
}
inline bool SimpleRequest::fill_username() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleRequest.fill_username)
  return _internal_fill_username();
}
inline void SimpleRequest::set_fill_username(bool value) {
  _internal_set_fill_username(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.SimpleRequest.fill_username)
}
inline bool SimpleRequest::_internal_fill_username() const {
  return _impl_.fill_username_;
}
inline void SimpleRequest::_internal_set_fill_username(bool value) {
  ;
  _impl_.fill_username_ = value;
}

// bool fill_oauth_scope = 5 [json_name = "fillOauthScope"];
inline void SimpleRequest::clear_fill_oauth_scope() {
  _impl_.fill_oauth_scope_ = false;
}
inline bool SimpleRequest::fill_oauth_scope() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleRequest.fill_oauth_scope)
  return _internal_fill_oauth_scope();
}
inline void SimpleRequest::set_fill_oauth_scope(bool value) {
  _internal_set_fill_oauth_scope(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.SimpleRequest.fill_oauth_scope)
}
inline bool SimpleRequest::_internal_fill_oauth_scope() const {
  return _impl_.fill_oauth_scope_;
}
inline void SimpleRequest::_internal_set_fill_oauth_scope(bool value) {
  ;
  _impl_.fill_oauth_scope_ = value;
}

// .google.protobuf.BoolValue response_compressed = 6 [json_name = "responseCompressed"];
inline bool SimpleRequest::has_response_compressed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_compressed_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SimpleRequest::_internal_response_compressed() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.response_compressed_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SimpleRequest::response_compressed() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleRequest.response_compressed)
  return _internal_response_compressed();
}
inline void SimpleRequest::unsafe_arena_set_allocated_response_compressed(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* response_compressed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_compressed_);
  }
  _impl_.response_compressed_ = response_compressed;
  if (response_compressed) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:connectrpc.conformance.v1.SimpleRequest.response_compressed)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SimpleRequest::release_response_compressed() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.response_compressed_;
  _impl_.response_compressed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SimpleRequest::unsafe_arena_release_response_compressed() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.SimpleRequest.response_compressed)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.response_compressed_;
  _impl_.response_compressed_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SimpleRequest::_internal_mutable_response_compressed() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.response_compressed_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.response_compressed_ = p;
  }
  return _impl_.response_compressed_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SimpleRequest::mutable_response_compressed() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_response_compressed();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.SimpleRequest.response_compressed)
  return _msg;
}
inline void SimpleRequest::set_allocated_response_compressed(::PROTOBUF_NAMESPACE_ID::BoolValue* response_compressed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_compressed_);
  }
  if (response_compressed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_compressed));
    if (message_arena != submessage_arena) {
      response_compressed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_compressed, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.response_compressed_ = response_compressed;
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.SimpleRequest.response_compressed)
}

// .connectrpc.conformance.v1.EchoStatus response_status = 7 [json_name = "responseStatus"];
inline bool SimpleRequest::has_response_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_status_ != nullptr);
  return value;
}
inline void SimpleRequest::clear_response_status() {
  if (_impl_.response_status_ != nullptr) _impl_.response_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::connectrpc::conformance::v1::EchoStatus& SimpleRequest::_internal_response_status() const {
  const ::connectrpc::conformance::v1::EchoStatus* p = _impl_.response_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::connectrpc::conformance::v1::EchoStatus&>(
      ::connectrpc::conformance::v1::_EchoStatus_default_instance_);
}
inline const ::connectrpc::conformance::v1::EchoStatus& SimpleRequest::response_status() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleRequest.response_status)
  return _internal_response_status();
}
inline void SimpleRequest::unsafe_arena_set_allocated_response_status(
    ::connectrpc::conformance::v1::EchoStatus* response_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_status_);
  }
  _impl_.response_status_ = response_status;
  if (response_status) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:connectrpc.conformance.v1.SimpleRequest.response_status)
}
inline ::connectrpc::conformance::v1::EchoStatus* SimpleRequest::release_response_status() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::connectrpc::conformance::v1::EchoStatus* temp = _impl_.response_status_;
  _impl_.response_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::connectrpc::conformance::v1::EchoStatus* SimpleRequest::unsafe_arena_release_response_status() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.SimpleRequest.response_status)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::connectrpc::conformance::v1::EchoStatus* temp = _impl_.response_status_;
  _impl_.response_status_ = nullptr;
  return temp;
}
inline ::connectrpc::conformance::v1::EchoStatus* SimpleRequest::_internal_mutable_response_status() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.response_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::connectrpc::conformance::v1::EchoStatus>(GetArenaForAllocation());
    _impl_.response_status_ = p;
  }
  return _impl_.response_status_;
}
inline ::connectrpc::conformance::v1::EchoStatus* SimpleRequest::mutable_response_status() {
  ::connectrpc::conformance::v1::EchoStatus* _msg = _internal_mutable_response_status();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.SimpleRequest.response_status)
  return _msg;
}
inline void SimpleRequest::set_allocated_response_status(::connectrpc::conformance::v1::EchoStatus* response_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_status_;
  }
  if (response_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_status);
    if (message_arena != submessage_arena) {
      response_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.response_status_ = response_status;
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.SimpleRequest.response_status)
}

// .google.protobuf.BoolValue expect_compressed = 8 [json_name = "expectCompressed"];
inline bool SimpleRequest::has_expect_compressed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expect_compressed_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SimpleRequest::_internal_expect_compressed() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.expect_compressed_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SimpleRequest::expect_compressed() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleRequest.expect_compressed)
  return _internal_expect_compressed();
}
inline void SimpleRequest::unsafe_arena_set_allocated_expect_compressed(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* expect_compressed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expect_compressed_);
  }
  _impl_.expect_compressed_ = expect_compressed;
  if (expect_compressed) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:connectrpc.conformance.v1.SimpleRequest.expect_compressed)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SimpleRequest::release_expect_compressed() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.expect_compressed_;
  _impl_.expect_compressed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SimpleRequest::unsafe_arena_release_expect_compressed() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.SimpleRequest.expect_compressed)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.expect_compressed_;
  _impl_.expect_compressed_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SimpleRequest::_internal_mutable_expect_compressed() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.expect_compressed_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.expect_compressed_ = p;
  }
  return _impl_.expect_compressed_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SimpleRequest::mutable_expect_compressed() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_expect_compressed();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.SimpleRequest.expect_compressed)
  return _msg;
}
inline void SimpleRequest::set_allocated_expect_compressed(::PROTOBUF_NAMESPACE_ID::BoolValue* expect_compressed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expect_compressed_);
  }
  if (expect_compressed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expect_compressed));
    if (message_arena != submessage_arena) {
      expect_compressed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expect_compressed, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.expect_compressed_ = expect_compressed;
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.SimpleRequest.expect_compressed)
}

// bool fill_server_id = 9 [json_name = "fillServerId"];
inline void SimpleRequest::clear_fill_server_id() {
  _impl_.fill_server_id_ = false;
}
inline bool SimpleRequest::fill_server_id() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleRequest.fill_server_id)
  return _internal_fill_server_id();
}
inline void SimpleRequest::set_fill_server_id(bool value) {
  _internal_set_fill_server_id(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.SimpleRequest.fill_server_id)
}
inline bool SimpleRequest::_internal_fill_server_id() const {
  return _impl_.fill_server_id_;
}
inline void SimpleRequest::_internal_set_fill_server_id(bool value) {
  ;
  _impl_.fill_server_id_ = value;
}

// bool fill_grpclb_route_type = 10 [json_name = "fillGrpclbRouteType"];
inline void SimpleRequest::clear_fill_grpclb_route_type() {
  _impl_.fill_grpclb_route_type_ = false;
}
inline bool SimpleRequest::fill_grpclb_route_type() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleRequest.fill_grpclb_route_type)
  return _internal_fill_grpclb_route_type();
}
inline void SimpleRequest::set_fill_grpclb_route_type(bool value) {
  _internal_set_fill_grpclb_route_type(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.SimpleRequest.fill_grpclb_route_type)
}
inline bool SimpleRequest::_internal_fill_grpclb_route_type() const {
  return _impl_.fill_grpclb_route_type_;
}
inline void SimpleRequest::_internal_set_fill_grpclb_route_type(bool value) {
  ;
  _impl_.fill_grpclb_route_type_ = value;
}

// -------------------------------------------------------------------

// SimpleResponse

// .connectrpc.conformance.v1.Payload payload = 1 [json_name = "payload"];
inline bool SimpleResponse::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline void SimpleResponse::clear_payload() {
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::connectrpc::conformance::v1::Payload& SimpleResponse::_internal_payload() const {
  const ::connectrpc::conformance::v1::Payload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::connectrpc::conformance::v1::Payload&>(
      ::connectrpc::conformance::v1::_Payload_default_instance_);
}
inline const ::connectrpc::conformance::v1::Payload& SimpleResponse::payload() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleResponse.payload)
  return _internal_payload();
}
inline void SimpleResponse::unsafe_arena_set_allocated_payload(
    ::connectrpc::conformance::v1::Payload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:connectrpc.conformance.v1.SimpleResponse.payload)
}
inline ::connectrpc::conformance::v1::Payload* SimpleResponse::release_payload() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::connectrpc::conformance::v1::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::connectrpc::conformance::v1::Payload* SimpleResponse::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.SimpleResponse.payload)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::connectrpc::conformance::v1::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::connectrpc::conformance::v1::Payload* SimpleResponse::_internal_mutable_payload() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::connectrpc::conformance::v1::Payload>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::connectrpc::conformance::v1::Payload* SimpleResponse::mutable_payload() {
  ::connectrpc::conformance::v1::Payload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.SimpleResponse.payload)
  return _msg;
}
inline void SimpleResponse::set_allocated_payload(::connectrpc::conformance::v1::Payload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.SimpleResponse.payload)
}

// string username = 2 [json_name = "username"];
inline void SimpleResponse::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& SimpleResponse::username() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleResponse.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SimpleResponse::set_username(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.SimpleResponse.username)
}
inline std::string* SimpleResponse::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.SimpleResponse.username)
  return _s;
}
inline const std::string& SimpleResponse::_internal_username() const {
  return _impl_.username_.Get();
}
inline void SimpleResponse::_internal_set_username(const std::string& value) {
  ;


  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* SimpleResponse::_internal_mutable_username() {
  ;
  return _impl_.username_.Mutable( GetArenaForAllocation());
}
inline std::string* SimpleResponse::release_username() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.SimpleResponse.username)
  return _impl_.username_.Release();
}
inline void SimpleResponse::set_allocated_username(std::string* value) {
  _impl_.username_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.SimpleResponse.username)
}

// string oauth_scope = 3 [json_name = "oauthScope"];
inline void SimpleResponse::clear_oauth_scope() {
  _impl_.oauth_scope_.ClearToEmpty();
}
inline const std::string& SimpleResponse::oauth_scope() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleResponse.oauth_scope)
  return _internal_oauth_scope();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SimpleResponse::set_oauth_scope(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oauth_scope_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.SimpleResponse.oauth_scope)
}
inline std::string* SimpleResponse::mutable_oauth_scope() {
  std::string* _s = _internal_mutable_oauth_scope();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.SimpleResponse.oauth_scope)
  return _s;
}
inline const std::string& SimpleResponse::_internal_oauth_scope() const {
  return _impl_.oauth_scope_.Get();
}
inline void SimpleResponse::_internal_set_oauth_scope(const std::string& value) {
  ;


  _impl_.oauth_scope_.Set(value, GetArenaForAllocation());
}
inline std::string* SimpleResponse::_internal_mutable_oauth_scope() {
  ;
  return _impl_.oauth_scope_.Mutable( GetArenaForAllocation());
}
inline std::string* SimpleResponse::release_oauth_scope() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.SimpleResponse.oauth_scope)
  return _impl_.oauth_scope_.Release();
}
inline void SimpleResponse::set_allocated_oauth_scope(std::string* value) {
  _impl_.oauth_scope_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oauth_scope_.IsDefault()) {
          _impl_.oauth_scope_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.SimpleResponse.oauth_scope)
}

// string server_id = 4 [json_name = "serverId"];
inline void SimpleResponse::clear_server_id() {
  _impl_.server_id_.ClearToEmpty();
}
inline const std::string& SimpleResponse::server_id() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleResponse.server_id)
  return _internal_server_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SimpleResponse::set_server_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.server_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.SimpleResponse.server_id)
}
inline std::string* SimpleResponse::mutable_server_id() {
  std::string* _s = _internal_mutable_server_id();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.SimpleResponse.server_id)
  return _s;
}
inline const std::string& SimpleResponse::_internal_server_id() const {
  return _impl_.server_id_.Get();
}
inline void SimpleResponse::_internal_set_server_id(const std::string& value) {
  ;


  _impl_.server_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SimpleResponse::_internal_mutable_server_id() {
  ;
  return _impl_.server_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SimpleResponse::release_server_id() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.SimpleResponse.server_id)
  return _impl_.server_id_.Release();
}
inline void SimpleResponse::set_allocated_server_id(std::string* value) {
  _impl_.server_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.server_id_.IsDefault()) {
          _impl_.server_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.SimpleResponse.server_id)
}

// .connectrpc.conformance.v1.GrpclbRouteType grpclb_route_type = 5 [json_name = "grpclbRouteType"];
inline void SimpleResponse::clear_grpclb_route_type() {
  _impl_.grpclb_route_type_ = 0;
}
inline ::connectrpc::conformance::v1::GrpclbRouteType SimpleResponse::grpclb_route_type() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleResponse.grpclb_route_type)
  return _internal_grpclb_route_type();
}
inline void SimpleResponse::set_grpclb_route_type(::connectrpc::conformance::v1::GrpclbRouteType value) {
   _internal_set_grpclb_route_type(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.SimpleResponse.grpclb_route_type)
}
inline ::connectrpc::conformance::v1::GrpclbRouteType SimpleResponse::_internal_grpclb_route_type() const {
  return static_cast<::connectrpc::conformance::v1::GrpclbRouteType>(_impl_.grpclb_route_type_);
}
inline void SimpleResponse::_internal_set_grpclb_route_type(::connectrpc::conformance::v1::GrpclbRouteType value) {
  ;
  _impl_.grpclb_route_type_ = value;
}

// string hostname = 6 [json_name = "hostname"];
inline void SimpleResponse::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& SimpleResponse::hostname() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.SimpleResponse.hostname)
  return _internal_hostname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SimpleResponse::set_hostname(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hostname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.SimpleResponse.hostname)
}
inline std::string* SimpleResponse::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.SimpleResponse.hostname)
  return _s;
}
inline const std::string& SimpleResponse::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void SimpleResponse::_internal_set_hostname(const std::string& value) {
  ;


  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* SimpleResponse::_internal_mutable_hostname() {
  ;
  return _impl_.hostname_.Mutable( GetArenaForAllocation());
}
inline std::string* SimpleResponse::release_hostname() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.SimpleResponse.hostname)
  return _impl_.hostname_.Release();
}
inline void SimpleResponse::set_allocated_hostname(std::string* value) {
  _impl_.hostname_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hostname_.IsDefault()) {
          _impl_.hostname_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.SimpleResponse.hostname)
}

// -------------------------------------------------------------------

// StreamingInputCallRequest

// .connectrpc.conformance.v1.Payload payload = 1 [json_name = "payload"];
inline bool StreamingInputCallRequest::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline void StreamingInputCallRequest::clear_payload() {
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::connectrpc::conformance::v1::Payload& StreamingInputCallRequest::_internal_payload() const {
  const ::connectrpc::conformance::v1::Payload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::connectrpc::conformance::v1::Payload&>(
      ::connectrpc::conformance::v1::_Payload_default_instance_);
}
inline const ::connectrpc::conformance::v1::Payload& StreamingInputCallRequest::payload() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.StreamingInputCallRequest.payload)
  return _internal_payload();
}
inline void StreamingInputCallRequest::unsafe_arena_set_allocated_payload(
    ::connectrpc::conformance::v1::Payload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:connectrpc.conformance.v1.StreamingInputCallRequest.payload)
}
inline ::connectrpc::conformance::v1::Payload* StreamingInputCallRequest::release_payload() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::connectrpc::conformance::v1::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::connectrpc::conformance::v1::Payload* StreamingInputCallRequest::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.StreamingInputCallRequest.payload)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::connectrpc::conformance::v1::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::connectrpc::conformance::v1::Payload* StreamingInputCallRequest::_internal_mutable_payload() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::connectrpc::conformance::v1::Payload>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::connectrpc::conformance::v1::Payload* StreamingInputCallRequest::mutable_payload() {
  ::connectrpc::conformance::v1::Payload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.StreamingInputCallRequest.payload)
  return _msg;
}
inline void StreamingInputCallRequest::set_allocated_payload(::connectrpc::conformance::v1::Payload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.StreamingInputCallRequest.payload)
}

// .google.protobuf.BoolValue expect_compressed = 2 [json_name = "expectCompressed"];
inline bool StreamingInputCallRequest::has_expect_compressed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expect_compressed_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& StreamingInputCallRequest::_internal_expect_compressed() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.expect_compressed_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& StreamingInputCallRequest::expect_compressed() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.StreamingInputCallRequest.expect_compressed)
  return _internal_expect_compressed();
}
inline void StreamingInputCallRequest::unsafe_arena_set_allocated_expect_compressed(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* expect_compressed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expect_compressed_);
  }
  _impl_.expect_compressed_ = expect_compressed;
  if (expect_compressed) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:connectrpc.conformance.v1.StreamingInputCallRequest.expect_compressed)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* StreamingInputCallRequest::release_expect_compressed() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.expect_compressed_;
  _impl_.expect_compressed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* StreamingInputCallRequest::unsafe_arena_release_expect_compressed() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.StreamingInputCallRequest.expect_compressed)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.expect_compressed_;
  _impl_.expect_compressed_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* StreamingInputCallRequest::_internal_mutable_expect_compressed() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.expect_compressed_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.expect_compressed_ = p;
  }
  return _impl_.expect_compressed_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* StreamingInputCallRequest::mutable_expect_compressed() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_expect_compressed();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.StreamingInputCallRequest.expect_compressed)
  return _msg;
}
inline void StreamingInputCallRequest::set_allocated_expect_compressed(::PROTOBUF_NAMESPACE_ID::BoolValue* expect_compressed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expect_compressed_);
  }
  if (expect_compressed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expect_compressed));
    if (message_arena != submessage_arena) {
      expect_compressed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expect_compressed, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.expect_compressed_ = expect_compressed;
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.StreamingInputCallRequest.expect_compressed)
}

// -------------------------------------------------------------------

// StreamingInputCallResponse

// int32 aggregated_payload_size = 1 [json_name = "aggregatedPayloadSize"];
inline void StreamingInputCallResponse::clear_aggregated_payload_size() {
  _impl_.aggregated_payload_size_ = 0;
}
inline ::int32_t StreamingInputCallResponse::aggregated_payload_size() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.StreamingInputCallResponse.aggregated_payload_size)
  return _internal_aggregated_payload_size();
}
inline void StreamingInputCallResponse::set_aggregated_payload_size(::int32_t value) {
  _internal_set_aggregated_payload_size(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.StreamingInputCallResponse.aggregated_payload_size)
}
inline ::int32_t StreamingInputCallResponse::_internal_aggregated_payload_size() const {
  return _impl_.aggregated_payload_size_;
}
inline void StreamingInputCallResponse::_internal_set_aggregated_payload_size(::int32_t value) {
  ;
  _impl_.aggregated_payload_size_ = value;
}

// -------------------------------------------------------------------

// ResponseParameters

// int32 size = 1 [json_name = "size"];
inline void ResponseParameters::clear_size() {
  _impl_.size_ = 0;
}
inline ::int32_t ResponseParameters::size() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ResponseParameters.size)
  return _internal_size();
}
inline void ResponseParameters::set_size(::int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.ResponseParameters.size)
}
inline ::int32_t ResponseParameters::_internal_size() const {
  return _impl_.size_;
}
inline void ResponseParameters::_internal_set_size(::int32_t value) {
  ;
  _impl_.size_ = value;
}

// int32 interval_us = 2 [json_name = "intervalUs"];
inline void ResponseParameters::clear_interval_us() {
  _impl_.interval_us_ = 0;
}
inline ::int32_t ResponseParameters::interval_us() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ResponseParameters.interval_us)
  return _internal_interval_us();
}
inline void ResponseParameters::set_interval_us(::int32_t value) {
  _internal_set_interval_us(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.ResponseParameters.interval_us)
}
inline ::int32_t ResponseParameters::_internal_interval_us() const {
  return _impl_.interval_us_;
}
inline void ResponseParameters::_internal_set_interval_us(::int32_t value) {
  ;
  _impl_.interval_us_ = value;
}

// .google.protobuf.BoolValue compressed = 3 [json_name = "compressed"];
inline bool ResponseParameters::has_compressed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.compressed_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ResponseParameters::_internal_compressed() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.compressed_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ResponseParameters::compressed() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ResponseParameters.compressed)
  return _internal_compressed();
}
inline void ResponseParameters::unsafe_arena_set_allocated_compressed(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* compressed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compressed_);
  }
  _impl_.compressed_ = compressed;
  if (compressed) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:connectrpc.conformance.v1.ResponseParameters.compressed)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ResponseParameters::release_compressed() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.compressed_;
  _impl_.compressed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ResponseParameters::unsafe_arena_release_compressed() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.ResponseParameters.compressed)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.compressed_;
  _impl_.compressed_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ResponseParameters::_internal_mutable_compressed() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.compressed_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.compressed_ = p;
  }
  return _impl_.compressed_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ResponseParameters::mutable_compressed() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_compressed();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.ResponseParameters.compressed)
  return _msg;
}
inline void ResponseParameters::set_allocated_compressed(::PROTOBUF_NAMESPACE_ID::BoolValue* compressed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compressed_);
  }
  if (compressed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(compressed));
    if (message_arena != submessage_arena) {
      compressed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compressed, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.compressed_ = compressed;
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.ResponseParameters.compressed)
}

// -------------------------------------------------------------------

// StreamingOutputCallRequest

// .connectrpc.conformance.v1.PayloadType response_type = 1 [json_name = "responseType"];
inline void StreamingOutputCallRequest::clear_response_type() {
  _impl_.response_type_ = 0;
}
inline ::connectrpc::conformance::v1::PayloadType StreamingOutputCallRequest::response_type() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.StreamingOutputCallRequest.response_type)
  return _internal_response_type();
}
inline void StreamingOutputCallRequest::set_response_type(::connectrpc::conformance::v1::PayloadType value) {
   _internal_set_response_type(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.StreamingOutputCallRequest.response_type)
}
inline ::connectrpc::conformance::v1::PayloadType StreamingOutputCallRequest::_internal_response_type() const {
  return static_cast<::connectrpc::conformance::v1::PayloadType>(_impl_.response_type_);
}
inline void StreamingOutputCallRequest::_internal_set_response_type(::connectrpc::conformance::v1::PayloadType value) {
  ;
  _impl_.response_type_ = value;
}

// repeated .connectrpc.conformance.v1.ResponseParameters response_parameters = 2 [json_name = "responseParameters"];
inline int StreamingOutputCallRequest::_internal_response_parameters_size() const {
  return _impl_.response_parameters_.size();
}
inline int StreamingOutputCallRequest::response_parameters_size() const {
  return _internal_response_parameters_size();
}
inline void StreamingOutputCallRequest::clear_response_parameters() {
  _internal_mutable_response_parameters()->Clear();
}
inline ::connectrpc::conformance::v1::ResponseParameters* StreamingOutputCallRequest::mutable_response_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.StreamingOutputCallRequest.response_parameters)
  return _internal_mutable_response_parameters()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::connectrpc::conformance::v1::ResponseParameters >*
StreamingOutputCallRequest::mutable_response_parameters() {
  // @@protoc_insertion_point(field_mutable_list:connectrpc.conformance.v1.StreamingOutputCallRequest.response_parameters)
  return _internal_mutable_response_parameters();
}
inline const ::connectrpc::conformance::v1::ResponseParameters& StreamingOutputCallRequest::_internal_response_parameters(int index) const {
  return _internal_response_parameters().Get(index);
}
inline const ::connectrpc::conformance::v1::ResponseParameters& StreamingOutputCallRequest::response_parameters(int index) const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.StreamingOutputCallRequest.response_parameters)
  return _internal_response_parameters(index);
}
inline ::connectrpc::conformance::v1::ResponseParameters* StreamingOutputCallRequest::_internal_add_response_parameters() {
  return _internal_mutable_response_parameters()->Add();
}
inline ::connectrpc::conformance::v1::ResponseParameters* StreamingOutputCallRequest::add_response_parameters() {
  ::connectrpc::conformance::v1::ResponseParameters* _add = _internal_add_response_parameters();
  // @@protoc_insertion_point(field_add:connectrpc.conformance.v1.StreamingOutputCallRequest.response_parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::connectrpc::conformance::v1::ResponseParameters >&
StreamingOutputCallRequest::response_parameters() const {
  // @@protoc_insertion_point(field_list:connectrpc.conformance.v1.StreamingOutputCallRequest.response_parameters)
  return _internal_response_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::connectrpc::conformance::v1::ResponseParameters>&
StreamingOutputCallRequest::_internal_response_parameters() const {
  return _impl_.response_parameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::connectrpc::conformance::v1::ResponseParameters>*
StreamingOutputCallRequest::_internal_mutable_response_parameters() {
  return &_impl_.response_parameters_;
}

// .connectrpc.conformance.v1.Payload payload = 3 [json_name = "payload"];
inline bool StreamingOutputCallRequest::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline void StreamingOutputCallRequest::clear_payload() {
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::connectrpc::conformance::v1::Payload& StreamingOutputCallRequest::_internal_payload() const {
  const ::connectrpc::conformance::v1::Payload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::connectrpc::conformance::v1::Payload&>(
      ::connectrpc::conformance::v1::_Payload_default_instance_);
}
inline const ::connectrpc::conformance::v1::Payload& StreamingOutputCallRequest::payload() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.StreamingOutputCallRequest.payload)
  return _internal_payload();
}
inline void StreamingOutputCallRequest::unsafe_arena_set_allocated_payload(
    ::connectrpc::conformance::v1::Payload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:connectrpc.conformance.v1.StreamingOutputCallRequest.payload)
}
inline ::connectrpc::conformance::v1::Payload* StreamingOutputCallRequest::release_payload() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::connectrpc::conformance::v1::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::connectrpc::conformance::v1::Payload* StreamingOutputCallRequest::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.StreamingOutputCallRequest.payload)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::connectrpc::conformance::v1::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::connectrpc::conformance::v1::Payload* StreamingOutputCallRequest::_internal_mutable_payload() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::connectrpc::conformance::v1::Payload>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::connectrpc::conformance::v1::Payload* StreamingOutputCallRequest::mutable_payload() {
  ::connectrpc::conformance::v1::Payload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.StreamingOutputCallRequest.payload)
  return _msg;
}
inline void StreamingOutputCallRequest::set_allocated_payload(::connectrpc::conformance::v1::Payload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.StreamingOutputCallRequest.payload)
}

// .connectrpc.conformance.v1.EchoStatus response_status = 7 [json_name = "responseStatus"];
inline bool StreamingOutputCallRequest::has_response_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_status_ != nullptr);
  return value;
}
inline void StreamingOutputCallRequest::clear_response_status() {
  if (_impl_.response_status_ != nullptr) _impl_.response_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::connectrpc::conformance::v1::EchoStatus& StreamingOutputCallRequest::_internal_response_status() const {
  const ::connectrpc::conformance::v1::EchoStatus* p = _impl_.response_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::connectrpc::conformance::v1::EchoStatus&>(
      ::connectrpc::conformance::v1::_EchoStatus_default_instance_);
}
inline const ::connectrpc::conformance::v1::EchoStatus& StreamingOutputCallRequest::response_status() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.StreamingOutputCallRequest.response_status)
  return _internal_response_status();
}
inline void StreamingOutputCallRequest::unsafe_arena_set_allocated_response_status(
    ::connectrpc::conformance::v1::EchoStatus* response_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_status_);
  }
  _impl_.response_status_ = response_status;
  if (response_status) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:connectrpc.conformance.v1.StreamingOutputCallRequest.response_status)
}
inline ::connectrpc::conformance::v1::EchoStatus* StreamingOutputCallRequest::release_response_status() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::connectrpc::conformance::v1::EchoStatus* temp = _impl_.response_status_;
  _impl_.response_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::connectrpc::conformance::v1::EchoStatus* StreamingOutputCallRequest::unsafe_arena_release_response_status() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.StreamingOutputCallRequest.response_status)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::connectrpc::conformance::v1::EchoStatus* temp = _impl_.response_status_;
  _impl_.response_status_ = nullptr;
  return temp;
}
inline ::connectrpc::conformance::v1::EchoStatus* StreamingOutputCallRequest::_internal_mutable_response_status() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.response_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::connectrpc::conformance::v1::EchoStatus>(GetArenaForAllocation());
    _impl_.response_status_ = p;
  }
  return _impl_.response_status_;
}
inline ::connectrpc::conformance::v1::EchoStatus* StreamingOutputCallRequest::mutable_response_status() {
  ::connectrpc::conformance::v1::EchoStatus* _msg = _internal_mutable_response_status();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.StreamingOutputCallRequest.response_status)
  return _msg;
}
inline void StreamingOutputCallRequest::set_allocated_response_status(::connectrpc::conformance::v1::EchoStatus* response_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_status_;
  }
  if (response_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_status);
    if (message_arena != submessage_arena) {
      response_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.response_status_ = response_status;
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.StreamingOutputCallRequest.response_status)
}

// -------------------------------------------------------------------

// StreamingOutputCallResponse

// .connectrpc.conformance.v1.Payload payload = 1 [json_name = "payload"];
inline bool StreamingOutputCallResponse::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline void StreamingOutputCallResponse::clear_payload() {
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::connectrpc::conformance::v1::Payload& StreamingOutputCallResponse::_internal_payload() const {
  const ::connectrpc::conformance::v1::Payload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::connectrpc::conformance::v1::Payload&>(
      ::connectrpc::conformance::v1::_Payload_default_instance_);
}
inline const ::connectrpc::conformance::v1::Payload& StreamingOutputCallResponse::payload() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.StreamingOutputCallResponse.payload)
  return _internal_payload();
}
inline void StreamingOutputCallResponse::unsafe_arena_set_allocated_payload(
    ::connectrpc::conformance::v1::Payload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:connectrpc.conformance.v1.StreamingOutputCallResponse.payload)
}
inline ::connectrpc::conformance::v1::Payload* StreamingOutputCallResponse::release_payload() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::connectrpc::conformance::v1::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::connectrpc::conformance::v1::Payload* StreamingOutputCallResponse::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.StreamingOutputCallResponse.payload)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::connectrpc::conformance::v1::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::connectrpc::conformance::v1::Payload* StreamingOutputCallResponse::_internal_mutable_payload() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::connectrpc::conformance::v1::Payload>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::connectrpc::conformance::v1::Payload* StreamingOutputCallResponse::mutable_payload() {
  ::connectrpc::conformance::v1::Payload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.StreamingOutputCallResponse.payload)
  return _msg;
}
inline void StreamingOutputCallResponse::set_allocated_payload(::connectrpc::conformance::v1::Payload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.StreamingOutputCallResponse.payload)
}

// -------------------------------------------------------------------

// ReconnectParams

// int32 max_reconnect_backoff_ms = 1 [json_name = "maxReconnectBackoffMs"];
inline void ReconnectParams::clear_max_reconnect_backoff_ms() {
  _impl_.max_reconnect_backoff_ms_ = 0;
}
inline ::int32_t ReconnectParams::max_reconnect_backoff_ms() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ReconnectParams.max_reconnect_backoff_ms)
  return _internal_max_reconnect_backoff_ms();
}
inline void ReconnectParams::set_max_reconnect_backoff_ms(::int32_t value) {
  _internal_set_max_reconnect_backoff_ms(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.ReconnectParams.max_reconnect_backoff_ms)
}
inline ::int32_t ReconnectParams::_internal_max_reconnect_backoff_ms() const {
  return _impl_.max_reconnect_backoff_ms_;
}
inline void ReconnectParams::_internal_set_max_reconnect_backoff_ms(::int32_t value) {
  ;
  _impl_.max_reconnect_backoff_ms_ = value;
}

// -------------------------------------------------------------------

// ReconnectInfo

// bool passed = 1 [json_name = "passed"];
inline void ReconnectInfo::clear_passed() {
  _impl_.passed_ = false;
}
inline bool ReconnectInfo::passed() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ReconnectInfo.passed)
  return _internal_passed();
}
inline void ReconnectInfo::set_passed(bool value) {
  _internal_set_passed(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.ReconnectInfo.passed)
}
inline bool ReconnectInfo::_internal_passed() const {
  return _impl_.passed_;
}
inline void ReconnectInfo::_internal_set_passed(bool value) {
  ;
  _impl_.passed_ = value;
}

// repeated int32 backoff_ms = 2 [json_name = "backoffMs"];
inline int ReconnectInfo::_internal_backoff_ms_size() const {
  return _impl_.backoff_ms_.size();
}
inline int ReconnectInfo::backoff_ms_size() const {
  return _internal_backoff_ms_size();
}
inline void ReconnectInfo::clear_backoff_ms() {
  _internal_mutable_backoff_ms()->Clear();
}
inline ::int32_t ReconnectInfo::backoff_ms(int index) const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ReconnectInfo.backoff_ms)
  return _internal_backoff_ms(index);
}
inline void ReconnectInfo::set_backoff_ms(int index, ::int32_t value) {
  _internal_mutable_backoff_ms()->Set(index, value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.ReconnectInfo.backoff_ms)
}
inline void ReconnectInfo::add_backoff_ms(::int32_t value) {
  _internal_add_backoff_ms(value);
  // @@protoc_insertion_point(field_add:connectrpc.conformance.v1.ReconnectInfo.backoff_ms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& ReconnectInfo::backoff_ms() const {
  // @@protoc_insertion_point(field_list:connectrpc.conformance.v1.ReconnectInfo.backoff_ms)
  return _internal_backoff_ms();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* ReconnectInfo::mutable_backoff_ms() {
  // @@protoc_insertion_point(field_mutable_list:connectrpc.conformance.v1.ReconnectInfo.backoff_ms)
  return _internal_mutable_backoff_ms();
}

inline ::int32_t ReconnectInfo::_internal_backoff_ms(int index) const {
  return _internal_backoff_ms().Get(index);
}
inline void ReconnectInfo::_internal_add_backoff_ms(::int32_t value) {
  _internal_mutable_backoff_ms()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& ReconnectInfo::_internal_backoff_ms() const {
  return _impl_.backoff_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* ReconnectInfo::_internal_mutable_backoff_ms() {
  return &_impl_.backoff_ms_;
}

// -------------------------------------------------------------------

// LoadBalancerStatsRequest

// int32 num_rpcs = 1 [json_name = "numRpcs"];
inline void LoadBalancerStatsRequest::clear_num_rpcs() {
  _impl_.num_rpcs_ = 0;
}
inline ::int32_t LoadBalancerStatsRequest::num_rpcs() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.LoadBalancerStatsRequest.num_rpcs)
  return _internal_num_rpcs();
}
inline void LoadBalancerStatsRequest::set_num_rpcs(::int32_t value) {
  _internal_set_num_rpcs(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.LoadBalancerStatsRequest.num_rpcs)
}
inline ::int32_t LoadBalancerStatsRequest::_internal_num_rpcs() const {
  return _impl_.num_rpcs_;
}
inline void LoadBalancerStatsRequest::_internal_set_num_rpcs(::int32_t value) {
  ;
  _impl_.num_rpcs_ = value;
}

// int32 timeout_sec = 2 [json_name = "timeoutSec"];
inline void LoadBalancerStatsRequest::clear_timeout_sec() {
  _impl_.timeout_sec_ = 0;
}
inline ::int32_t LoadBalancerStatsRequest::timeout_sec() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.LoadBalancerStatsRequest.timeout_sec)
  return _internal_timeout_sec();
}
inline void LoadBalancerStatsRequest::set_timeout_sec(::int32_t value) {
  _internal_set_timeout_sec(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.LoadBalancerStatsRequest.timeout_sec)
}
inline ::int32_t LoadBalancerStatsRequest::_internal_timeout_sec() const {
  return _impl_.timeout_sec_;
}
inline void LoadBalancerStatsRequest::_internal_set_timeout_sec(::int32_t value) {
  ;
  _impl_.timeout_sec_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LoadBalancerStatsResponse_RpcsByPeer

// map<string, int32> rpcs_by_peer = 1 [json_name = "rpcsByPeer"];
inline int LoadBalancerStatsResponse_RpcsByPeer::_internal_rpcs_by_peer_size() const {
  return _impl_.rpcs_by_peer_.size();
}
inline int LoadBalancerStatsResponse_RpcsByPeer::rpcs_by_peer_size() const {
  return _internal_rpcs_by_peer_size();
}
inline void LoadBalancerStatsResponse_RpcsByPeer::clear_rpcs_by_peer() {
  _impl_.rpcs_by_peer_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
LoadBalancerStatsResponse_RpcsByPeer::_internal_rpcs_by_peer() const {
  return _impl_.rpcs_by_peer_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
LoadBalancerStatsResponse_RpcsByPeer::rpcs_by_peer() const {
  // @@protoc_insertion_point(field_map:connectrpc.conformance.v1.LoadBalancerStatsResponse.RpcsByPeer.rpcs_by_peer)
  return _internal_rpcs_by_peer();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
LoadBalancerStatsResponse_RpcsByPeer::_internal_mutable_rpcs_by_peer() {
  return _impl_.rpcs_by_peer_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
LoadBalancerStatsResponse_RpcsByPeer::mutable_rpcs_by_peer() {
  // @@protoc_insertion_point(field_mutable_map:connectrpc.conformance.v1.LoadBalancerStatsResponse.RpcsByPeer.rpcs_by_peer)
  return _internal_mutable_rpcs_by_peer();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LoadBalancerStatsResponse

// map<string, int32> rpcs_by_peer = 1 [json_name = "rpcsByPeer"];
inline int LoadBalancerStatsResponse::_internal_rpcs_by_peer_size() const {
  return _impl_.rpcs_by_peer_.size();
}
inline int LoadBalancerStatsResponse::rpcs_by_peer_size() const {
  return _internal_rpcs_by_peer_size();
}
inline void LoadBalancerStatsResponse::clear_rpcs_by_peer() {
  _impl_.rpcs_by_peer_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
LoadBalancerStatsResponse::_internal_rpcs_by_peer() const {
  return _impl_.rpcs_by_peer_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
LoadBalancerStatsResponse::rpcs_by_peer() const {
  // @@protoc_insertion_point(field_map:connectrpc.conformance.v1.LoadBalancerStatsResponse.rpcs_by_peer)
  return _internal_rpcs_by_peer();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
LoadBalancerStatsResponse::_internal_mutable_rpcs_by_peer() {
  return _impl_.rpcs_by_peer_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
LoadBalancerStatsResponse::mutable_rpcs_by_peer() {
  // @@protoc_insertion_point(field_mutable_map:connectrpc.conformance.v1.LoadBalancerStatsResponse.rpcs_by_peer)
  return _internal_mutable_rpcs_by_peer();
}

// int32 num_failures = 2 [json_name = "numFailures"];
inline void LoadBalancerStatsResponse::clear_num_failures() {
  _impl_.num_failures_ = 0;
}
inline ::int32_t LoadBalancerStatsResponse::num_failures() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.LoadBalancerStatsResponse.num_failures)
  return _internal_num_failures();
}
inline void LoadBalancerStatsResponse::set_num_failures(::int32_t value) {
  _internal_set_num_failures(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.LoadBalancerStatsResponse.num_failures)
}
inline ::int32_t LoadBalancerStatsResponse::_internal_num_failures() const {
  return _impl_.num_failures_;
}
inline void LoadBalancerStatsResponse::_internal_set_num_failures(::int32_t value) {
  ;
  _impl_.num_failures_ = value;
}

// map<string, .connectrpc.conformance.v1.LoadBalancerStatsResponse.RpcsByPeer> rpcs_by_method = 3 [json_name = "rpcsByMethod"];
inline int LoadBalancerStatsResponse::_internal_rpcs_by_method_size() const {
  return _impl_.rpcs_by_method_.size();
}
inline int LoadBalancerStatsResponse::rpcs_by_method_size() const {
  return _internal_rpcs_by_method_size();
}
inline void LoadBalancerStatsResponse::clear_rpcs_by_method() {
  _impl_.rpcs_by_method_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer >&
LoadBalancerStatsResponse::_internal_rpcs_by_method() const {
  return _impl_.rpcs_by_method_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer >&
LoadBalancerStatsResponse::rpcs_by_method() const {
  // @@protoc_insertion_point(field_map:connectrpc.conformance.v1.LoadBalancerStatsResponse.rpcs_by_method)
  return _internal_rpcs_by_method();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer >*
LoadBalancerStatsResponse::_internal_mutable_rpcs_by_method() {
  return _impl_.rpcs_by_method_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerStatsResponse_RpcsByPeer >*
LoadBalancerStatsResponse::mutable_rpcs_by_method() {
  // @@protoc_insertion_point(field_mutable_map:connectrpc.conformance.v1.LoadBalancerStatsResponse.rpcs_by_method)
  return _internal_mutable_rpcs_by_method();
}

// -------------------------------------------------------------------

// LoadBalancerAccumulatedStatsRequest

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LoadBalancerAccumulatedStatsResponse_MethodStats

// int32 rpcs_started = 1 [json_name = "rpcsStarted"];
inline void LoadBalancerAccumulatedStatsResponse_MethodStats::clear_rpcs_started() {
  _impl_.rpcs_started_ = 0;
}
inline ::int32_t LoadBalancerAccumulatedStatsResponse_MethodStats::rpcs_started() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.MethodStats.rpcs_started)
  return _internal_rpcs_started();
}
inline void LoadBalancerAccumulatedStatsResponse_MethodStats::set_rpcs_started(::int32_t value) {
  _internal_set_rpcs_started(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.MethodStats.rpcs_started)
}
inline ::int32_t LoadBalancerAccumulatedStatsResponse_MethodStats::_internal_rpcs_started() const {
  return _impl_.rpcs_started_;
}
inline void LoadBalancerAccumulatedStatsResponse_MethodStats::_internal_set_rpcs_started(::int32_t value) {
  ;
  _impl_.rpcs_started_ = value;
}

// map<int32, int32> result = 2 [json_name = "result"];
inline int LoadBalancerAccumulatedStatsResponse_MethodStats::_internal_result_size() const {
  return _impl_.result_.size();
}
inline int LoadBalancerAccumulatedStatsResponse_MethodStats::result_size() const {
  return _internal_result_size();
}
inline void LoadBalancerAccumulatedStatsResponse_MethodStats::clear_result() {
  _impl_.result_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::int32_t >&
LoadBalancerAccumulatedStatsResponse_MethodStats::_internal_result() const {
  return _impl_.result_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::int32_t >&
LoadBalancerAccumulatedStatsResponse_MethodStats::result() const {
  // @@protoc_insertion_point(field_map:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.MethodStats.result)
  return _internal_result();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::int32_t >*
LoadBalancerAccumulatedStatsResponse_MethodStats::_internal_mutable_result() {
  return _impl_.result_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::int32_t >*
LoadBalancerAccumulatedStatsResponse_MethodStats::mutable_result() {
  // @@protoc_insertion_point(field_mutable_map:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.MethodStats.result)
  return _internal_mutable_result();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LoadBalancerAccumulatedStatsResponse

// map<string, int32> num_rpcs_started_by_method = 1 [json_name = "numRpcsStartedByMethod", deprecated = true];
inline int LoadBalancerAccumulatedStatsResponse::_internal_num_rpcs_started_by_method_size() const {
  return _impl_.num_rpcs_started_by_method_.size();
}
inline int LoadBalancerAccumulatedStatsResponse::num_rpcs_started_by_method_size() const {
  return _internal_num_rpcs_started_by_method_size();
}
inline void LoadBalancerAccumulatedStatsResponse::clear_num_rpcs_started_by_method() {
  _impl_.num_rpcs_started_by_method_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
LoadBalancerAccumulatedStatsResponse::_internal_num_rpcs_started_by_method() const {
  return _impl_.num_rpcs_started_by_method_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
LoadBalancerAccumulatedStatsResponse::num_rpcs_started_by_method() const {
  // @@protoc_insertion_point(field_map:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.num_rpcs_started_by_method)
  return _internal_num_rpcs_started_by_method();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
LoadBalancerAccumulatedStatsResponse::_internal_mutable_num_rpcs_started_by_method() {
  return _impl_.num_rpcs_started_by_method_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
LoadBalancerAccumulatedStatsResponse::mutable_num_rpcs_started_by_method() {
  // @@protoc_insertion_point(field_mutable_map:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.num_rpcs_started_by_method)
  return _internal_mutable_num_rpcs_started_by_method();
}

// map<string, int32> num_rpcs_succeeded_by_method = 2 [json_name = "numRpcsSucceededByMethod", deprecated = true];
inline int LoadBalancerAccumulatedStatsResponse::_internal_num_rpcs_succeeded_by_method_size() const {
  return _impl_.num_rpcs_succeeded_by_method_.size();
}
inline int LoadBalancerAccumulatedStatsResponse::num_rpcs_succeeded_by_method_size() const {
  return _internal_num_rpcs_succeeded_by_method_size();
}
inline void LoadBalancerAccumulatedStatsResponse::clear_num_rpcs_succeeded_by_method() {
  _impl_.num_rpcs_succeeded_by_method_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
LoadBalancerAccumulatedStatsResponse::_internal_num_rpcs_succeeded_by_method() const {
  return _impl_.num_rpcs_succeeded_by_method_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
LoadBalancerAccumulatedStatsResponse::num_rpcs_succeeded_by_method() const {
  // @@protoc_insertion_point(field_map:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.num_rpcs_succeeded_by_method)
  return _internal_num_rpcs_succeeded_by_method();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
LoadBalancerAccumulatedStatsResponse::_internal_mutable_num_rpcs_succeeded_by_method() {
  return _impl_.num_rpcs_succeeded_by_method_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
LoadBalancerAccumulatedStatsResponse::mutable_num_rpcs_succeeded_by_method() {
  // @@protoc_insertion_point(field_mutable_map:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.num_rpcs_succeeded_by_method)
  return _internal_mutable_num_rpcs_succeeded_by_method();
}

// map<string, int32> num_rpcs_failed_by_method = 3 [json_name = "numRpcsFailedByMethod", deprecated = true];
inline int LoadBalancerAccumulatedStatsResponse::_internal_num_rpcs_failed_by_method_size() const {
  return _impl_.num_rpcs_failed_by_method_.size();
}
inline int LoadBalancerAccumulatedStatsResponse::num_rpcs_failed_by_method_size() const {
  return _internal_num_rpcs_failed_by_method_size();
}
inline void LoadBalancerAccumulatedStatsResponse::clear_num_rpcs_failed_by_method() {
  _impl_.num_rpcs_failed_by_method_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
LoadBalancerAccumulatedStatsResponse::_internal_num_rpcs_failed_by_method() const {
  return _impl_.num_rpcs_failed_by_method_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >&
LoadBalancerAccumulatedStatsResponse::num_rpcs_failed_by_method() const {
  // @@protoc_insertion_point(field_map:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.num_rpcs_failed_by_method)
  return _internal_num_rpcs_failed_by_method();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
LoadBalancerAccumulatedStatsResponse::_internal_mutable_num_rpcs_failed_by_method() {
  return _impl_.num_rpcs_failed_by_method_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::int32_t >*
LoadBalancerAccumulatedStatsResponse::mutable_num_rpcs_failed_by_method() {
  // @@protoc_insertion_point(field_mutable_map:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.num_rpcs_failed_by_method)
  return _internal_mutable_num_rpcs_failed_by_method();
}

// map<string, .connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.MethodStats> stats_per_method = 4 [json_name = "statsPerMethod"];
inline int LoadBalancerAccumulatedStatsResponse::_internal_stats_per_method_size() const {
  return _impl_.stats_per_method_.size();
}
inline int LoadBalancerAccumulatedStatsResponse::stats_per_method_size() const {
  return _internal_stats_per_method_size();
}
inline void LoadBalancerAccumulatedStatsResponse::clear_stats_per_method() {
  _impl_.stats_per_method_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats >&
LoadBalancerAccumulatedStatsResponse::_internal_stats_per_method() const {
  return _impl_.stats_per_method_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats >&
LoadBalancerAccumulatedStatsResponse::stats_per_method() const {
  // @@protoc_insertion_point(field_map:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.stats_per_method)
  return _internal_stats_per_method();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats >*
LoadBalancerAccumulatedStatsResponse::_internal_mutable_stats_per_method() {
  return _impl_.stats_per_method_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::connectrpc::conformance::v1::LoadBalancerAccumulatedStatsResponse_MethodStats >*
LoadBalancerAccumulatedStatsResponse::mutable_stats_per_method() {
  // @@protoc_insertion_point(field_mutable_map:connectrpc.conformance.v1.LoadBalancerAccumulatedStatsResponse.stats_per_method)
  return _internal_mutable_stats_per_method();
}

// -------------------------------------------------------------------

// ClientConfigureRequest_Metadata

// .connectrpc.conformance.v1.ClientConfigureRequest.RpcType type = 1 [json_name = "type"];
inline void ClientConfigureRequest_Metadata::clear_type() {
  _impl_.type_ = 0;
}
inline ::connectrpc::conformance::v1::ClientConfigureRequest_RpcType ClientConfigureRequest_Metadata::type() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ClientConfigureRequest.Metadata.type)
  return _internal_type();
}
inline void ClientConfigureRequest_Metadata::set_type(::connectrpc::conformance::v1::ClientConfigureRequest_RpcType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.ClientConfigureRequest.Metadata.type)
}
inline ::connectrpc::conformance::v1::ClientConfigureRequest_RpcType ClientConfigureRequest_Metadata::_internal_type() const {
  return static_cast<::connectrpc::conformance::v1::ClientConfigureRequest_RpcType>(_impl_.type_);
}
inline void ClientConfigureRequest_Metadata::_internal_set_type(::connectrpc::conformance::v1::ClientConfigureRequest_RpcType value) {
  ;
  _impl_.type_ = value;
}

// string key = 2 [json_name = "key"];
inline void ClientConfigureRequest_Metadata::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ClientConfigureRequest_Metadata::key() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ClientConfigureRequest.Metadata.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientConfigureRequest_Metadata::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.ClientConfigureRequest.Metadata.key)
}
inline std::string* ClientConfigureRequest_Metadata::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.ClientConfigureRequest.Metadata.key)
  return _s;
}
inline const std::string& ClientConfigureRequest_Metadata::_internal_key() const {
  return _impl_.key_.Get();
}
inline void ClientConfigureRequest_Metadata::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientConfigureRequest_Metadata::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* ClientConfigureRequest_Metadata::release_key() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.ClientConfigureRequest.Metadata.key)
  return _impl_.key_.Release();
}
inline void ClientConfigureRequest_Metadata::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.ClientConfigureRequest.Metadata.key)
}

// string value = 3 [json_name = "value"];
inline void ClientConfigureRequest_Metadata::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ClientConfigureRequest_Metadata::value() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ClientConfigureRequest.Metadata.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientConfigureRequest_Metadata::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.ClientConfigureRequest.Metadata.value)
}
inline std::string* ClientConfigureRequest_Metadata::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.ClientConfigureRequest.Metadata.value)
  return _s;
}
inline const std::string& ClientConfigureRequest_Metadata::_internal_value() const {
  return _impl_.value_.Get();
}
inline void ClientConfigureRequest_Metadata::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientConfigureRequest_Metadata::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* ClientConfigureRequest_Metadata::release_value() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.ClientConfigureRequest.Metadata.value)
  return _impl_.value_.Release();
}
inline void ClientConfigureRequest_Metadata::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.ClientConfigureRequest.Metadata.value)
}

// -------------------------------------------------------------------

// ClientConfigureRequest

// repeated .connectrpc.conformance.v1.ClientConfigureRequest.RpcType types = 1 [json_name = "types"];
inline int ClientConfigureRequest::_internal_types_size() const {
  return _impl_.types_.size();
}
inline int ClientConfigureRequest::types_size() const {
  return _internal_types_size();
}
inline void ClientConfigureRequest::clear_types() {
  _internal_mutable_types()->Clear();
}
inline ::connectrpc::conformance::v1::ClientConfigureRequest_RpcType ClientConfigureRequest::types(int index) const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ClientConfigureRequest.types)
  return _internal_types(index);
}
inline void ClientConfigureRequest::set_types(int index, ::connectrpc::conformance::v1::ClientConfigureRequest_RpcType value) {
  _internal_mutable_types()->Set(index, value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.ClientConfigureRequest.types)
}
inline void ClientConfigureRequest::add_types(::connectrpc::conformance::v1::ClientConfigureRequest_RpcType value) {
  _internal_add_types(value);
  // @@protoc_insertion_point(field_add:connectrpc.conformance.v1.ClientConfigureRequest.types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ClientConfigureRequest::types() const {
  // @@protoc_insertion_point(field_list:connectrpc.conformance.v1.ClientConfigureRequest.types)
  return _internal_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ClientConfigureRequest::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:connectrpc.conformance.v1.ClientConfigureRequest.types)
  return _internal_mutable_types();
}
inline ::connectrpc::conformance::v1::ClientConfigureRequest_RpcType ClientConfigureRequest::_internal_types(int index) const {
  return static_cast<::connectrpc::conformance::v1::ClientConfigureRequest_RpcType>(_internal_types().Get(index));
}
inline void ClientConfigureRequest::_internal_add_types(::connectrpc::conformance::v1::ClientConfigureRequest_RpcType value) {
  _internal_mutable_types()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ClientConfigureRequest::_internal_types() const {
  return _impl_.types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ClientConfigureRequest::_internal_mutable_types() {
  return &_impl_.types_;
}

// repeated .connectrpc.conformance.v1.ClientConfigureRequest.Metadata metadata = 2 [json_name = "metadata"];
inline int ClientConfigureRequest::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int ClientConfigureRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void ClientConfigureRequest::clear_metadata() {
  _internal_mutable_metadata()->Clear();
}
inline ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata* ClientConfigureRequest::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.ClientConfigureRequest.metadata)
  return _internal_mutable_metadata()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata >*
ClientConfigureRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:connectrpc.conformance.v1.ClientConfigureRequest.metadata)
  return _internal_mutable_metadata();
}
inline const ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata& ClientConfigureRequest::_internal_metadata(int index) const {
  return _internal_metadata().Get(index);
}
inline const ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata& ClientConfigureRequest::metadata(int index) const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ClientConfigureRequest.metadata)
  return _internal_metadata(index);
}
inline ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata* ClientConfigureRequest::_internal_add_metadata() {
  return _internal_mutable_metadata()->Add();
}
inline ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata* ClientConfigureRequest::add_metadata() {
  ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata* _add = _internal_add_metadata();
  // @@protoc_insertion_point(field_add:connectrpc.conformance.v1.ClientConfigureRequest.metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::connectrpc::conformance::v1::ClientConfigureRequest_Metadata >&
ClientConfigureRequest::metadata() const {
  // @@protoc_insertion_point(field_list:connectrpc.conformance.v1.ClientConfigureRequest.metadata)
  return _internal_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::connectrpc::conformance::v1::ClientConfigureRequest_Metadata>&
ClientConfigureRequest::_internal_metadata() const {
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::connectrpc::conformance::v1::ClientConfigureRequest_Metadata>*
ClientConfigureRequest::_internal_mutable_metadata() {
  return &_impl_.metadata_;
}

// int32 timeout_sec = 3 [json_name = "timeoutSec"];
inline void ClientConfigureRequest::clear_timeout_sec() {
  _impl_.timeout_sec_ = 0;
}
inline ::int32_t ClientConfigureRequest::timeout_sec() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ClientConfigureRequest.timeout_sec)
  return _internal_timeout_sec();
}
inline void ClientConfigureRequest::set_timeout_sec(::int32_t value) {
  _internal_set_timeout_sec(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.ClientConfigureRequest.timeout_sec)
}
inline ::int32_t ClientConfigureRequest::_internal_timeout_sec() const {
  return _impl_.timeout_sec_;
}
inline void ClientConfigureRequest::_internal_set_timeout_sec(::int32_t value) {
  ;
  _impl_.timeout_sec_ = value;
}

// -------------------------------------------------------------------

// ClientConfigureResponse

// -------------------------------------------------------------------

// ErrorDetail

// string reason = 1 [json_name = "reason"];
inline void ErrorDetail::clear_reason() {
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& ErrorDetail::reason() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ErrorDetail.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorDetail::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.ErrorDetail.reason)
}
inline std::string* ErrorDetail::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.ErrorDetail.reason)
  return _s;
}
inline const std::string& ErrorDetail::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void ErrorDetail::_internal_set_reason(const std::string& value) {
  ;


  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorDetail::_internal_mutable_reason() {
  ;
  return _impl_.reason_.Mutable( GetArenaForAllocation());
}
inline std::string* ErrorDetail::release_reason() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.ErrorDetail.reason)
  return _impl_.reason_.Release();
}
inline void ErrorDetail::set_allocated_reason(std::string* value) {
  _impl_.reason_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.ErrorDetail.reason)
}

// string domain = 2 [json_name = "domain"];
inline void ErrorDetail::clear_domain() {
  _impl_.domain_.ClearToEmpty();
}
inline const std::string& ErrorDetail::domain() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ErrorDetail.domain)
  return _internal_domain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorDetail::set_domain(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.domain_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.ErrorDetail.domain)
}
inline std::string* ErrorDetail::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.ErrorDetail.domain)
  return _s;
}
inline const std::string& ErrorDetail::_internal_domain() const {
  return _impl_.domain_.Get();
}
inline void ErrorDetail::_internal_set_domain(const std::string& value) {
  ;


  _impl_.domain_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorDetail::_internal_mutable_domain() {
  ;
  return _impl_.domain_.Mutable( GetArenaForAllocation());
}
inline std::string* ErrorDetail::release_domain() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.ErrorDetail.domain)
  return _impl_.domain_.Release();
}
inline void ErrorDetail::set_allocated_domain(std::string* value) {
  _impl_.domain_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.domain_.IsDefault()) {
          _impl_.domain_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.ErrorDetail.domain)
}

// -------------------------------------------------------------------

// ErrorStatus

// int32 code = 1 [json_name = "code"];
inline void ErrorStatus::clear_code() {
  _impl_.code_ = 0;
}
inline ::int32_t ErrorStatus::code() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ErrorStatus.code)
  return _internal_code();
}
inline void ErrorStatus::set_code(::int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.ErrorStatus.code)
}
inline ::int32_t ErrorStatus::_internal_code() const {
  return _impl_.code_;
}
inline void ErrorStatus::_internal_set_code(::int32_t value) {
  ;
  _impl_.code_ = value;
}

// string message = 2 [json_name = "message"];
inline void ErrorStatus::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ErrorStatus::message() const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ErrorStatus.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorStatus::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:connectrpc.conformance.v1.ErrorStatus.message)
}
inline std::string* ErrorStatus::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.ErrorStatus.message)
  return _s;
}
inline const std::string& ErrorStatus::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ErrorStatus::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorStatus::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* ErrorStatus::release_message() {
  // @@protoc_insertion_point(field_release:connectrpc.conformance.v1.ErrorStatus.message)
  return _impl_.message_.Release();
}
inline void ErrorStatus::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:connectrpc.conformance.v1.ErrorStatus.message)
}

// repeated .google.protobuf.Any details = 3 [json_name = "details"];
inline int ErrorStatus::_internal_details_size() const {
  return _impl_.details_.size();
}
inline int ErrorStatus::details_size() const {
  return _internal_details_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ErrorStatus::mutable_details(int index) {
  // @@protoc_insertion_point(field_mutable:connectrpc.conformance.v1.ErrorStatus.details)
  return _internal_mutable_details()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
ErrorStatus::mutable_details() {
  // @@protoc_insertion_point(field_mutable_list:connectrpc.conformance.v1.ErrorStatus.details)
  return _internal_mutable_details();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ErrorStatus::_internal_details(int index) const {
  return _internal_details().Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ErrorStatus::details(int index) const {
  // @@protoc_insertion_point(field_get:connectrpc.conformance.v1.ErrorStatus.details)
  return _internal_details(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ErrorStatus::_internal_add_details() {
  return _internal_mutable_details()->Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ErrorStatus::add_details() {
  ::PROTOBUF_NAMESPACE_ID::Any* _add = _internal_add_details();
  // @@protoc_insertion_point(field_add:connectrpc.conformance.v1.ErrorStatus.details)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
ErrorStatus::details() const {
  // @@protoc_insertion_point(field_list:connectrpc.conformance.v1.ErrorStatus.details)
  return _internal_details();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::PROTOBUF_NAMESPACE_ID::Any>&
ErrorStatus::_internal_details() const {
  return _impl_.details_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::PROTOBUF_NAMESPACE_ID::Any>*
ErrorStatus::_internal_mutable_details() {
  return &_impl_.details_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace conformance
}  // namespace connectrpc


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::connectrpc::conformance::v1::ClientConfigureRequest_RpcType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::connectrpc::conformance::v1::ClientConfigureRequest_RpcType>() {
  return ::connectrpc::conformance::v1::ClientConfigureRequest_RpcType_descriptor();
}
template <>
struct is_proto_enum<::connectrpc::conformance::v1::PayloadType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::connectrpc::conformance::v1::PayloadType>() {
  return ::connectrpc::conformance::v1::PayloadType_descriptor();
}
template <>
struct is_proto_enum<::connectrpc::conformance::v1::GrpclbRouteType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::connectrpc::conformance::v1::GrpclbRouteType>() {
  return ::connectrpc::conformance::v1::GrpclbRouteType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_connectrpc_2fconformance_2fv1_2fmessages_2eproto_2epb_2eh
