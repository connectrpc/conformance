# Testing Servers

Testing servers with the conformance runner involves the following steps:

* Implementing the ConformanceService endpoints.
* Making an executable file that will read messages from `stdin` and write messages to `stdout`.
* Defining any configuration for what your server supports. For more information on how to do this, see the docs for [configuring and running tests](./configuring_and_running_tests.md#configuration-files).

## Process

The basic process for working with servers in the conformance suite will work as follows:

* The conformance runner will pass a `ServerCompatRequest` message via `stdin`. This message will contain all the details necessary
  for your implementation to start its server-under-test. Note that the request does not specify a port to listen on.
  Implementations should instead pick an available ephemeral port according to their OS and return that value in the response.

  Fields in the request are:

  * `protocol` specifies what protocol will be used to run the tests. 
  * `http_version` specifies which HTTP version will be used.
  * `use_tls` specifies whether your server should generate a self-signed certificate. Clients will be configured to trust
     this certificate when connecting. If `true`, the generated certificate should be returned in the `pem_cert` field of the
     `ServerCompatResponse`. If this is set to `false`, the server should not use TLS and instead use a plaintext/unencrypted socket.
  * `client_tls_cert` represents a PEM-encoded certificate that, if provided, clients will use to authenticate themselves. 
     If specified, servers should require that clients provide certificates and they should ensure the presented certificate is valid.
     Note that this will always be empty if `use_tls` is `false`.
  * `message_receive_limit` specifies the maximum size in bytes for a message. If this value is non-zero, servers should reject
     any message from a client that is larger than the size indicated.

* Once the server is started, your implementation should then write a `ServerCompatResponse` message to `stdout`. This will
  provide the conformance runner with details about your running server.

  * `host` should be set with the host where your server is running. 
  * `port` should be set with the port number where your server is listening.
  * `pem_cert` should contain the self-signed certificate generated by your server if `use_tls` was set to `true`. Clients
     will verify this certificate when connecting via TLS. If `use_tls` was set to `false`, this should always be empty.

## Implementing the ConformanceService

The ConformanceService defines a series of endpoints that are meant to exercise all types of RPCs. The details
in the requests will specify various attributes that the server should handle, such as determining response headers and 
trailers to return, any errors to throw, and any data to respond with. All request types contain a response definition 
which is used to instruct the server how to respond to the request. This response definition can also be unset entirely
and servers should respond in a fashion specific to their RPC type. The various approaches are outlined below.

Servers must also echo back the received request data in their responses and the method for doing so will vary depending 
on the type of RPC. The `ConformancePayload` message is a field on all RPC response types. Servers will use this field 
to echo back these details. This will include:

* Any response data
* Information observed from the request such as:
  * Request headers
  * Any timeout specified
  * All request bodies received
  * Any query parameters observed (only applicable for GET operations such as `IdempotentUnary`)

In all, there are six total endpoints you will need to implement. Below is a brief description of each with helpful pseudocode
for your implementation.

### Unary

The `Unary` endpoint is a unary operation that accepts a single request of type `UnaryRequest` and returns a single 
response of type `UnaryResponse`. 

The `UnaryRequest` contains a `response_definition` that tells the server how to respond. This definition contains a 
`oneof` which specifies whether the server should return valid response data or return an error. Servers should also 
allow this response definition to be unset. In which case, they should set no response headers or trailers and return 
no response data. The returned conformance payload should only contain the observed request information.

**Pseudocode**

```text
read the request

capture any request headers and the actual request body as request info

if a response definition was specified then
  if response definition specifies valid response data then

    build a conformance payload

    set the request info and response data into the conformance payload

  else
    build an error with the specified error and set the request info into the error details

  set any response headers or trailers indicated in the response definition

else
  build a conformance payload

  set the request info into the conformance payload

sleep for any specified response delay

return the response with conformance payload or the error depending on which was specified
```

For the full documentation on implementing the `Unary` endpoint, click [here][unary].


### IdempotentUnary

The `IdempotentUnary` endpoint is also a unary operation. It accepts a request of type  `IdempotentUnaryRequest` and returns
a single response of type `IdempotentUnaryResponse`. It should be handled in mostly the same way as `Unary`.

The only major difference is that this endpoint should be invoked via an HTTP `GET`. As a result, there is no request body
so the endpoint should read any query params and set them accordingly in the `connect_get_info` field of the 
returned `ConformancePayload`. This RPC is the only one that sets the `connect_get_info` field.

For the full documentation on implementing the `IdempotentUnary` endpoint, click [here][idempotentunary].

### Unimplemented

The `Unimplemented` endpoint is also a unary operation, but contrary to the above unary endpoints, the implementation
of `Unimplemented` should simply return an `unimplemented` error. It is not necessary to echo back any request information or
conformance payload in the error details.

For the full documentation on handling the `Unimplemented` endpoint, click [here][unimplemented].

### ClientStream

The `ClientStream` endpoint is a client-streaming operation. It accepts one-to-many requests of type `ClientStreamRequest`
and returns a single response of type `ClientStreamResponse`. Since a client-streaming operation returns a single response, 
its process is similar to `Unary`.

With client-streaming, the response definition will only be specified in the first request on the stream and should be
ignored in all subsequent requests. As with `Unary`, servers should also allow this response definition to be unset. In 
which case, they should set no response headers or trailers and return no response data. The returned conformance 
payload should only contain the observed request information.

**Pseudocode**

```text
while requests are being sent do the following
   read a request from the stream

   capture the request body

   if this is the first message being received then
      save the response definition

when requests are complete then
  if a response definition was specified then
    if response definition specifies valid response data then

      build a conformance payload

      set the request info and response data into the conformance payload

    else
      build an error with the specified error and set the request info into the error details

    set any response headers or trailers indicated in the response definition

  else
    build a conformance payload

    set the request info into the conformance payload

sleep for any specified response delay

return the response or the error depending on which was specified
```

For the full documentation on handling the `ClientStream` endpoint, click [here][clientstream].

### ServerStream

The `ServerStream` endpoint is a server-streaming operation. It accepts a single request of type `ServerStreamRequest` and
returns one-to-many response of type `ServerStreamResponse`. When echoing request information back, the `ServerStream`
implementation should only set this information in the first response sent.

Servers should immediately send response headers on the stream before sleeping
for any specified response delay and/or sending the first message so that
clients can be unblocked reading response headers.
  
If a response definition is not specified OR is specified, but response data
is empty, the server should skip sending anything on the stream. When there
are no responses to send, servers should throw an error if one is provided
and return without error if one is not. Stream headers and trailers should
still be set on the stream if provided regardless of whether a response is
sent or an error is thrown.

**Pseudocode**

```text
read the request

capture any request headers, the response definition and the actual request body as request info

if a response definition was specified then
  set any response headers or trailers on the response stream

  immediately send the headers/trailers on the stream so that they can be read by the client

  loop over any response data specified
    build a conformance payload

    set the response data into the conformance payload

    if this is the first response being sent then
      set the request info into the conformance payload
 
    sleep for any specified response delay

    send the response

  if an error was specified in the response definition then
    if no responses have been sent yet
      build an error with the specified error

      set the following into the error details
        * the received request
        * any request headers
```

For the full documentation on handling the `ServerStream` endpoint, click [here][serverstream].

### BidiStream

The `BidiStream` endpoint is a bidirectional-streaming operation. It accepts 
one-to-many requests of type `BidiStreamRequest` and returns one-to-many 
responses of type `BidiStreamResponse`. 

Similar to `ServerStream`, servers should immediately send response headers on 
the stream before sleeping for any specified response delay and/or sending the 
first message so that clients can be unblocked reading response headers.
  
If a response definition is not specified OR is specified, but response data
is empty, the server should skip sending anything on the stream. When there
are no responses to send, servers should throw an error if one is provided
and return without error if one is not. Stream headers and trailers should
still be set on the stream if provided regardless of whether a response is
sent or an error is thrown.

The `BidiStreamRequest` type specifies whether the operation should be full duplex
or half duplex via the `full_duplex` field.

If the `full_duplex` field is true:

* the handler should read one request and then send back one response, and
  then alternate, reading another request and then sending back another response, etc.
  
* if the server receives a request and has no responses to send, it
  should throw the error specified in the request.
  
* the service should echo back all request properties in the first response
  including the last received request. Subsequent responses should only
  echo back the last received request.
  
* if the `response_delay_ms` duration is specified, the server should wait the given
  duration after reading the request before sending the corresponding
  response.
  
If the `full_duplex` field is false:

* the handler should read all requests until the client is done sending.
  Once all requests are read, the server should then send back any responses
  specified in the response definition.
  
* the server should echo back all request properties, including all request
  messages in the order they were received, in the first response. Subsequent
  responses should only include the message data in the data field.
  
* if the `response_delay_ms` duration is specified, the server should wait that
  long in between sending each response message.

**Pseudocode**

```text
while requests are being sent do the following
   read a request from the stream

   capture the request body

   if this is the first message being received then
      save the response definition
      save whether this is full duplex or half duplex

      if a response definition was specified then
         set any response headers or trailers on the response stream
         
         if full duplex then
            immediately send the headers/trailers on the stream so that they can be read by the client
   
   if full duplex then
     if response data was specified then
       build a conformance payload

       set the response data into the conformance payload

       if this is the first response being sent then
         set the request info into the conformance payload
    
         sleep for any specified response delay

         send a response

  if half duplex and if response data was specified then
    immediately send the headers/trailers on the stream so that they can be read by the client

    loop over any response data specified
      build a conformance payload

      set the response data into the conformance payload

      if this is the first response being sent then
        set the request info into the conformance payload
 
        sleep for any specified response delay

        send the response

    if an error was specified in the response definition then
      if no responses have been sent yet
        build an Error object with the specified error

        set the following into the error details
        * the received request
        * any request headers
```

For the full documentation on handling the `BidiStream` endpoint, click [here][bidistream].

## Examples

For examples, check out the following:

* [Connect-ES conformance tests][connect-es-conformance] - This shows the entire process described above in TypeScript/JavaScript.
* [Connect-Go reference implementation][server-reference-impl] - For an example of implementing a server in Go, take a look at the reference server implementation used as part of the conformance runner.

[connect-es-conformance]: https://github.com/connectrpc/connect-es/tree/main/packages/connect-conformance 
[server-reference-impl]: https://github.com/connectrpc/conformance/blob/main/internal/app/referenceserver/impl.go
[unary]: https://buf.build/connectrpc/conformance/docs/main:connectrpc.conformance.v1#connectrpc.conformance.v1.ConformanceService.Unary
[idempotentunary]: https://buf.build/connectrpc/conformance/docs/main:connectrpc.conformance.v1#connectrpc.conformance.v1.ConformanceService.IdempotentUnary
[unimplemented]: https://buf.build/connectrpc/conformance/docs/main:connectrpc.conformance.v1#connectrpc.conformance.v1.ConformanceService.Unimplemented
[clientstream]: https://buf.build/connectrpc/conformance/docs/main:connectrpc.conformance.v1#connectrpc.conformance.v1.ConformanceService.ClientStream
[serverstream]: https://buf.build/connectrpc/conformance/docs/main:connectrpc.conformance.v1#connectrpc.conformance.v1.ConformanceService.ServerStream
[bidistream]: https://buf.build/connectrpc/conformance/docs/main:connectrpc.conformance.v1#connectrpc.conformance.v1.ConformanceService.BidiStream
