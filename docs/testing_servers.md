# Testing Servers

Testing servers with the conformance runner involves the following steps:

* Implementing the ConformanceService endpoints.
* Making an executable file that will read messages from `stdin` and write messages to `stdout`.
* Defining any configuration for what your server supports. For more information on how to do this, see the [Configuring and Running Tests documentation](./configuring_and_running_tests.md).

## Process

The basic process for working with servers in the conformance suite will work as follows:

* The conformance runner will pass a `ServerCompatRequest` message via `stdin`. This message will contain all the details necessary
  for your implementation to start its server-under-test. Note that the request does not specify a port to listen on.
  Implementations should instead pick an available ephemeral port according to their OS and return that value in the response.

  `protocol` specifies what protocol will be used to run the tests. 
  `http_version` specifies which HTTP version will be used.
  `use_tls` specifies whether your server should generated a self-signed certificate. Clients will be configured to trust
   this certificate when connecting. If `true`, the generated certificate should be returned in the `pem_cert` field of the
   `ServerCompatResponse`. If this is set to false, the server should not use TLS and instead use a plaintext/unencrypted socket.
  `client_tls_cert` represents a PEM-encoded certificate that, if provided, clients will use to authenticate themselves. 
   If specified, servers should require that clients provide certificates and they should validate the presented certificate is valid.
   Note that this will always be empty if `use_tls` is `false`.
  `message_receive_limit` specifies the maximum size in bytes for a message. If this value is non-zero, servers should reject
   any message from a client that is larger than the size indicated.

* Once the server is started, your implementation should then write a `ServerCompatResponse` message to `stdout`. This will
  provide the conformance runner with details about your running server.

  `host` should be set with the host where your server is running. 
  `port` should be set with the port number where your server is listening.
  `pem_cert` should contain the self-signed certificate generated by your server if `use_tls` was set to `true`. Clients
   will verify this certificate when connecting via TLS. If `use_tls` was set to `false`, this should always be empty.

## Implementing the ConformanceService

The ConformanceService defines a series of endpoints that are meant to exercise all types of RPCs. The basic
approach for all six is that the server accepts the request(s), reads the details, and then reacts accordingly. The details
in the requests will specify various actions that server should take such as response headers and trailers to return, any errors
to return, and any response data to return. Servers mustl also echo back the received request data in their responses.
The method for doing so will vary depending on the type of RPC.

In all, there are six total endpoints you will need to implement. Below is a brief description of each with helpful pseudocode
for your implementation.

### Unary

The `Unary` endpoint is a unary operation that accepts a single request of type `UnaryRequest` and returns a single response of type `UnaryResponse`.
The `UnaryRequest` contains a `response_definition` that tells the server how to respond. This definition contains a `oneof` which specifies
whether the server should return valid response data or return an error.

```text
capture all request info sent including:
* any request headers
* the actual request body
* any timeout sent
  
if response definition specifies valid response data then
  build a ConformancePayload object and set the request info as well as the specified response data

else
  build an Error object with the specified error and set the request info into the error details

set any response headers or trailers indicated in the response definition

sleep for any specified response delay

send the response
```

For the full documentation on implementing the `Unary` endpoint, click [here][unary].


### IdempotentUnary

### Unimplemented

### ClientStream

### ServerStream

### BidiStream

## Examples

For examples, check out the following:

* [Connect-ES conformance tests][connect-es-conformance] - This shows the entire process described above in TypeScript/JavaScript.
* [Connect-Go reference implementation][server-reference-impl] - For an example of implementing a server in Go, take a look at the reference server implementation used as part of the conformance runner.

[connect-es-conformance]: https://github.com/connectrpc/connect-es/tree/main/packages/connect-conformance 
[server-reference-impl]: https://github.com/connectrpc/conformance/blob/main/internal/app/referenceserver/impl.go
[unary]: https://buf.build/connectrpc/conformance/docs/main:connectrpc.conformance.v1#connectrpc.conformance.v1.ConformanceService.Unary
