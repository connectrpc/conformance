// Copyright 2022 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: connectrpc/conformance/test.proto

package conformanceconnect

import (
	context "context"
	errors "errors"
	conformance "github.com/bufbuild/connect-crosstest/internal/gen/proto/go/connectrpc/conformance"
	connect_go "github.com/bufbuild/connect-go"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion1_7_0

const (
	// TestServiceName is the fully-qualified name of the TestService service.
	TestServiceName = "connectrpc.conformance.TestService"
	// UnimplementedServiceName is the fully-qualified name of the UnimplementedService service.
	UnimplementedServiceName = "connectrpc.conformance.UnimplementedService"
	// ReconnectServiceName is the fully-qualified name of the ReconnectService service.
	ReconnectServiceName = "connectrpc.conformance.ReconnectService"
	// LoadBalancerStatsServiceName is the fully-qualified name of the LoadBalancerStatsService service.
	LoadBalancerStatsServiceName = "connectrpc.conformance.LoadBalancerStatsService"
	// XdsUpdateHealthServiceName is the fully-qualified name of the XdsUpdateHealthService service.
	XdsUpdateHealthServiceName = "connectrpc.conformance.XdsUpdateHealthService"
	// XdsUpdateClientConfigureServiceName is the fully-qualified name of the
	// XdsUpdateClientConfigureService service.
	XdsUpdateClientConfigureServiceName = "connectrpc.conformance.XdsUpdateClientConfigureService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// TestServiceEmptyCallProcedure is the fully-qualified name of the TestService's EmptyCall RPC.
	TestServiceEmptyCallProcedure = "/connectrpc.conformance.TestService/EmptyCall"
	// TestServiceUnaryCallProcedure is the fully-qualified name of the TestService's UnaryCall RPC.
	TestServiceUnaryCallProcedure = "/connectrpc.conformance.TestService/UnaryCall"
	// TestServiceFailUnaryCallProcedure is the fully-qualified name of the TestService's FailUnaryCall
	// RPC.
	TestServiceFailUnaryCallProcedure = "/connectrpc.conformance.TestService/FailUnaryCall"
	// TestServiceCacheableUnaryCallProcedure is the fully-qualified name of the TestService's
	// CacheableUnaryCall RPC.
	TestServiceCacheableUnaryCallProcedure = "/connectrpc.conformance.TestService/CacheableUnaryCall"
	// TestServiceStreamingOutputCallProcedure is the fully-qualified name of the TestService's
	// StreamingOutputCall RPC.
	TestServiceStreamingOutputCallProcedure = "/connectrpc.conformance.TestService/StreamingOutputCall"
	// TestServiceFailStreamingOutputCallProcedure is the fully-qualified name of the TestService's
	// FailStreamingOutputCall RPC.
	TestServiceFailStreamingOutputCallProcedure = "/connectrpc.conformance.TestService/FailStreamingOutputCall"
	// TestServiceStreamingInputCallProcedure is the fully-qualified name of the TestService's
	// StreamingInputCall RPC.
	TestServiceStreamingInputCallProcedure = "/connectrpc.conformance.TestService/StreamingInputCall"
	// TestServiceFullDuplexCallProcedure is the fully-qualified name of the TestService's
	// FullDuplexCall RPC.
	TestServiceFullDuplexCallProcedure = "/connectrpc.conformance.TestService/FullDuplexCall"
	// TestServiceHalfDuplexCallProcedure is the fully-qualified name of the TestService's
	// HalfDuplexCall RPC.
	TestServiceHalfDuplexCallProcedure = "/connectrpc.conformance.TestService/HalfDuplexCall"
	// TestServiceUnimplementedCallProcedure is the fully-qualified name of the TestService's
	// UnimplementedCall RPC.
	TestServiceUnimplementedCallProcedure = "/connectrpc.conformance.TestService/UnimplementedCall"
	// TestServiceUnimplementedStreamingOutputCallProcedure is the fully-qualified name of the
	// TestService's UnimplementedStreamingOutputCall RPC.
	TestServiceUnimplementedStreamingOutputCallProcedure = "/connectrpc.conformance.TestService/UnimplementedStreamingOutputCall"
	// UnimplementedServiceUnimplementedCallProcedure is the fully-qualified name of the
	// UnimplementedService's UnimplementedCall RPC.
	UnimplementedServiceUnimplementedCallProcedure = "/connectrpc.conformance.UnimplementedService/UnimplementedCall"
	// UnimplementedServiceUnimplementedStreamingOutputCallProcedure is the fully-qualified name of the
	// UnimplementedService's UnimplementedStreamingOutputCall RPC.
	UnimplementedServiceUnimplementedStreamingOutputCallProcedure = "/connectrpc.conformance.UnimplementedService/UnimplementedStreamingOutputCall"
	// ReconnectServiceStartProcedure is the fully-qualified name of the ReconnectService's Start RPC.
	ReconnectServiceStartProcedure = "/connectrpc.conformance.ReconnectService/Start"
	// ReconnectServiceStopProcedure is the fully-qualified name of the ReconnectService's Stop RPC.
	ReconnectServiceStopProcedure = "/connectrpc.conformance.ReconnectService/Stop"
	// LoadBalancerStatsServiceGetClientStatsProcedure is the fully-qualified name of the
	// LoadBalancerStatsService's GetClientStats RPC.
	LoadBalancerStatsServiceGetClientStatsProcedure = "/connectrpc.conformance.LoadBalancerStatsService/GetClientStats"
	// LoadBalancerStatsServiceGetClientAccumulatedStatsProcedure is the fully-qualified name of the
	// LoadBalancerStatsService's GetClientAccumulatedStats RPC.
	LoadBalancerStatsServiceGetClientAccumulatedStatsProcedure = "/connectrpc.conformance.LoadBalancerStatsService/GetClientAccumulatedStats"
	// XdsUpdateHealthServiceSetServingProcedure is the fully-qualified name of the
	// XdsUpdateHealthService's SetServing RPC.
	XdsUpdateHealthServiceSetServingProcedure = "/connectrpc.conformance.XdsUpdateHealthService/SetServing"
	// XdsUpdateHealthServiceSetNotServingProcedure is the fully-qualified name of the
	// XdsUpdateHealthService's SetNotServing RPC.
	XdsUpdateHealthServiceSetNotServingProcedure = "/connectrpc.conformance.XdsUpdateHealthService/SetNotServing"
	// XdsUpdateClientConfigureServiceConfigureProcedure is the fully-qualified name of the
	// XdsUpdateClientConfigureService's Configure RPC.
	XdsUpdateClientConfigureServiceConfigureProcedure = "/connectrpc.conformance.XdsUpdateClientConfigureService/Configure"
)

// TestServiceClient is a client for the connectrpc.conformance.TestService service.
type TestServiceClient interface {
	// One empty request followed by one empty response.
	EmptyCall(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error)
	// One request followed by one response.
	UnaryCall(context.Context, *connect_go.Request[conformance.SimpleRequest]) (*connect_go.Response[conformance.SimpleResponse], error)
	// One request followed by one response. This RPC always fails.
	FailUnaryCall(context.Context, *connect_go.Request[conformance.SimpleRequest]) (*connect_go.Response[conformance.SimpleResponse], error)
	// One request followed by one response. Response has cache control
	// headers set such that a caching HTTP proxy (such as GFE) can
	// satisfy subsequent requests.
	CacheableUnaryCall(context.Context, *connect_go.Request[conformance.SimpleRequest]) (*connect_go.Response[conformance.SimpleResponse], error)
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	StreamingOutputCall(context.Context, *connect_go.Request[conformance.StreamingOutputCallRequest]) (*connect_go.ServerStreamForClient[conformance.StreamingOutputCallResponse], error)
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	// This RPC always responds with an error status.
	FailStreamingOutputCall(context.Context, *connect_go.Request[conformance.StreamingOutputCallRequest]) (*connect_go.ServerStreamForClient[conformance.StreamingOutputCallResponse], error)
	// A sequence of requests followed by one response (streamed upload).
	// The server returns the aggregated size of client payload as the result.
	StreamingInputCall(context.Context) *connect_go.ClientStreamForClient[conformance.StreamingInputCallRequest, conformance.StreamingInputCallResponse]
	// A sequence of requests with each request served by the server immediately.
	// As one request could lead to multiple responses, this interface
	// demonstrates the idea of full duplexing.
	FullDuplexCall(context.Context) *connect_go.BidiStreamForClient[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse]
	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client requests and then serves them in order. A
	// stream of responses are returned to the client when the server starts with
	// first request.
	HalfDuplexCall(context.Context) *connect_go.BidiStreamForClient[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse]
	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented methods.
	UnimplementedCall(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error)
	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented streaming output methods.
	UnimplementedStreamingOutputCall(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.ServerStreamForClient[emptypb.Empty], error)
}

// NewTestServiceClient constructs a client for the connectrpc.conformance.TestService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewTestServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) TestServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &testServiceClient{
		emptyCall: connect_go.NewClient[emptypb.Empty, emptypb.Empty](
			httpClient,
			baseURL+TestServiceEmptyCallProcedure,
			opts...,
		),
		unaryCall: connect_go.NewClient[conformance.SimpleRequest, conformance.SimpleResponse](
			httpClient,
			baseURL+TestServiceUnaryCallProcedure,
			opts...,
		),
		failUnaryCall: connect_go.NewClient[conformance.SimpleRequest, conformance.SimpleResponse](
			httpClient,
			baseURL+TestServiceFailUnaryCallProcedure,
			opts...,
		),
		cacheableUnaryCall: connect_go.NewClient[conformance.SimpleRequest, conformance.SimpleResponse](
			httpClient,
			baseURL+TestServiceCacheableUnaryCallProcedure,
			connect_go.WithIdempotency(connect_go.IdempotencyNoSideEffects),
			connect_go.WithClientOptions(opts...),
		),
		streamingOutputCall: connect_go.NewClient[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse](
			httpClient,
			baseURL+TestServiceStreamingOutputCallProcedure,
			opts...,
		),
		failStreamingOutputCall: connect_go.NewClient[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse](
			httpClient,
			baseURL+TestServiceFailStreamingOutputCallProcedure,
			opts...,
		),
		streamingInputCall: connect_go.NewClient[conformance.StreamingInputCallRequest, conformance.StreamingInputCallResponse](
			httpClient,
			baseURL+TestServiceStreamingInputCallProcedure,
			opts...,
		),
		fullDuplexCall: connect_go.NewClient[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse](
			httpClient,
			baseURL+TestServiceFullDuplexCallProcedure,
			opts...,
		),
		halfDuplexCall: connect_go.NewClient[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse](
			httpClient,
			baseURL+TestServiceHalfDuplexCallProcedure,
			opts...,
		),
		unimplementedCall: connect_go.NewClient[emptypb.Empty, emptypb.Empty](
			httpClient,
			baseURL+TestServiceUnimplementedCallProcedure,
			opts...,
		),
		unimplementedStreamingOutputCall: connect_go.NewClient[emptypb.Empty, emptypb.Empty](
			httpClient,
			baseURL+TestServiceUnimplementedStreamingOutputCallProcedure,
			opts...,
		),
	}
}

// testServiceClient implements TestServiceClient.
type testServiceClient struct {
	emptyCall                        *connect_go.Client[emptypb.Empty, emptypb.Empty]
	unaryCall                        *connect_go.Client[conformance.SimpleRequest, conformance.SimpleResponse]
	failUnaryCall                    *connect_go.Client[conformance.SimpleRequest, conformance.SimpleResponse]
	cacheableUnaryCall               *connect_go.Client[conformance.SimpleRequest, conformance.SimpleResponse]
	streamingOutputCall              *connect_go.Client[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse]
	failStreamingOutputCall          *connect_go.Client[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse]
	streamingInputCall               *connect_go.Client[conformance.StreamingInputCallRequest, conformance.StreamingInputCallResponse]
	fullDuplexCall                   *connect_go.Client[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse]
	halfDuplexCall                   *connect_go.Client[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse]
	unimplementedCall                *connect_go.Client[emptypb.Empty, emptypb.Empty]
	unimplementedStreamingOutputCall *connect_go.Client[emptypb.Empty, emptypb.Empty]
}

// EmptyCall calls connectrpc.conformance.TestService.EmptyCall.
func (c *testServiceClient) EmptyCall(ctx context.Context, req *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error) {
	return c.emptyCall.CallUnary(ctx, req)
}

// UnaryCall calls connectrpc.conformance.TestService.UnaryCall.
func (c *testServiceClient) UnaryCall(ctx context.Context, req *connect_go.Request[conformance.SimpleRequest]) (*connect_go.Response[conformance.SimpleResponse], error) {
	return c.unaryCall.CallUnary(ctx, req)
}

// FailUnaryCall calls connectrpc.conformance.TestService.FailUnaryCall.
func (c *testServiceClient) FailUnaryCall(ctx context.Context, req *connect_go.Request[conformance.SimpleRequest]) (*connect_go.Response[conformance.SimpleResponse], error) {
	return c.failUnaryCall.CallUnary(ctx, req)
}

// CacheableUnaryCall calls connectrpc.conformance.TestService.CacheableUnaryCall.
func (c *testServiceClient) CacheableUnaryCall(ctx context.Context, req *connect_go.Request[conformance.SimpleRequest]) (*connect_go.Response[conformance.SimpleResponse], error) {
	return c.cacheableUnaryCall.CallUnary(ctx, req)
}

// StreamingOutputCall calls connectrpc.conformance.TestService.StreamingOutputCall.
func (c *testServiceClient) StreamingOutputCall(ctx context.Context, req *connect_go.Request[conformance.StreamingOutputCallRequest]) (*connect_go.ServerStreamForClient[conformance.StreamingOutputCallResponse], error) {
	return c.streamingOutputCall.CallServerStream(ctx, req)
}

// FailStreamingOutputCall calls connectrpc.conformance.TestService.FailStreamingOutputCall.
func (c *testServiceClient) FailStreamingOutputCall(ctx context.Context, req *connect_go.Request[conformance.StreamingOutputCallRequest]) (*connect_go.ServerStreamForClient[conformance.StreamingOutputCallResponse], error) {
	return c.failStreamingOutputCall.CallServerStream(ctx, req)
}

// StreamingInputCall calls connectrpc.conformance.TestService.StreamingInputCall.
func (c *testServiceClient) StreamingInputCall(ctx context.Context) *connect_go.ClientStreamForClient[conformance.StreamingInputCallRequest, conformance.StreamingInputCallResponse] {
	return c.streamingInputCall.CallClientStream(ctx)
}

// FullDuplexCall calls connectrpc.conformance.TestService.FullDuplexCall.
func (c *testServiceClient) FullDuplexCall(ctx context.Context) *connect_go.BidiStreamForClient[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse] {
	return c.fullDuplexCall.CallBidiStream(ctx)
}

// HalfDuplexCall calls connectrpc.conformance.TestService.HalfDuplexCall.
func (c *testServiceClient) HalfDuplexCall(ctx context.Context) *connect_go.BidiStreamForClient[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse] {
	return c.halfDuplexCall.CallBidiStream(ctx)
}

// UnimplementedCall calls connectrpc.conformance.TestService.UnimplementedCall.
func (c *testServiceClient) UnimplementedCall(ctx context.Context, req *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error) {
	return c.unimplementedCall.CallUnary(ctx, req)
}

// UnimplementedStreamingOutputCall calls
// connectrpc.conformance.TestService.UnimplementedStreamingOutputCall.
func (c *testServiceClient) UnimplementedStreamingOutputCall(ctx context.Context, req *connect_go.Request[emptypb.Empty]) (*connect_go.ServerStreamForClient[emptypb.Empty], error) {
	return c.unimplementedStreamingOutputCall.CallServerStream(ctx, req)
}

// TestServiceHandler is an implementation of the connectrpc.conformance.TestService service.
type TestServiceHandler interface {
	// One empty request followed by one empty response.
	EmptyCall(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error)
	// One request followed by one response.
	UnaryCall(context.Context, *connect_go.Request[conformance.SimpleRequest]) (*connect_go.Response[conformance.SimpleResponse], error)
	// One request followed by one response. This RPC always fails.
	FailUnaryCall(context.Context, *connect_go.Request[conformance.SimpleRequest]) (*connect_go.Response[conformance.SimpleResponse], error)
	// One request followed by one response. Response has cache control
	// headers set such that a caching HTTP proxy (such as GFE) can
	// satisfy subsequent requests.
	CacheableUnaryCall(context.Context, *connect_go.Request[conformance.SimpleRequest]) (*connect_go.Response[conformance.SimpleResponse], error)
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	StreamingOutputCall(context.Context, *connect_go.Request[conformance.StreamingOutputCallRequest], *connect_go.ServerStream[conformance.StreamingOutputCallResponse]) error
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	// This RPC always responds with an error status.
	FailStreamingOutputCall(context.Context, *connect_go.Request[conformance.StreamingOutputCallRequest], *connect_go.ServerStream[conformance.StreamingOutputCallResponse]) error
	// A sequence of requests followed by one response (streamed upload).
	// The server returns the aggregated size of client payload as the result.
	StreamingInputCall(context.Context, *connect_go.ClientStream[conformance.StreamingInputCallRequest]) (*connect_go.Response[conformance.StreamingInputCallResponse], error)
	// A sequence of requests with each request served by the server immediately.
	// As one request could lead to multiple responses, this interface
	// demonstrates the idea of full duplexing.
	FullDuplexCall(context.Context, *connect_go.BidiStream[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse]) error
	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client requests and then serves them in order. A
	// stream of responses are returned to the client when the server starts with
	// first request.
	HalfDuplexCall(context.Context, *connect_go.BidiStream[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse]) error
	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented methods.
	UnimplementedCall(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error)
	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented streaming output methods.
	UnimplementedStreamingOutputCall(context.Context, *connect_go.Request[emptypb.Empty], *connect_go.ServerStream[emptypb.Empty]) error
}

// NewTestServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewTestServiceHandler(svc TestServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	testServiceEmptyCallHandler := connect_go.NewUnaryHandler(
		TestServiceEmptyCallProcedure,
		svc.EmptyCall,
		opts...,
	)
	testServiceUnaryCallHandler := connect_go.NewUnaryHandler(
		TestServiceUnaryCallProcedure,
		svc.UnaryCall,
		opts...,
	)
	testServiceFailUnaryCallHandler := connect_go.NewUnaryHandler(
		TestServiceFailUnaryCallProcedure,
		svc.FailUnaryCall,
		opts...,
	)
	testServiceCacheableUnaryCallHandler := connect_go.NewUnaryHandler(
		TestServiceCacheableUnaryCallProcedure,
		svc.CacheableUnaryCall,
		connect_go.WithIdempotency(connect_go.IdempotencyNoSideEffects),
		connect_go.WithHandlerOptions(opts...),
	)
	testServiceStreamingOutputCallHandler := connect_go.NewServerStreamHandler(
		TestServiceStreamingOutputCallProcedure,
		svc.StreamingOutputCall,
		opts...,
	)
	testServiceFailStreamingOutputCallHandler := connect_go.NewServerStreamHandler(
		TestServiceFailStreamingOutputCallProcedure,
		svc.FailStreamingOutputCall,
		opts...,
	)
	testServiceStreamingInputCallHandler := connect_go.NewClientStreamHandler(
		TestServiceStreamingInputCallProcedure,
		svc.StreamingInputCall,
		opts...,
	)
	testServiceFullDuplexCallHandler := connect_go.NewBidiStreamHandler(
		TestServiceFullDuplexCallProcedure,
		svc.FullDuplexCall,
		opts...,
	)
	testServiceHalfDuplexCallHandler := connect_go.NewBidiStreamHandler(
		TestServiceHalfDuplexCallProcedure,
		svc.HalfDuplexCall,
		opts...,
	)
	testServiceUnimplementedCallHandler := connect_go.NewUnaryHandler(
		TestServiceUnimplementedCallProcedure,
		svc.UnimplementedCall,
		opts...,
	)
	testServiceUnimplementedStreamingOutputCallHandler := connect_go.NewServerStreamHandler(
		TestServiceUnimplementedStreamingOutputCallProcedure,
		svc.UnimplementedStreamingOutputCall,
		opts...,
	)
	return "/connectrpc.conformance.TestService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case TestServiceEmptyCallProcedure:
			testServiceEmptyCallHandler.ServeHTTP(w, r)
		case TestServiceUnaryCallProcedure:
			testServiceUnaryCallHandler.ServeHTTP(w, r)
		case TestServiceFailUnaryCallProcedure:
			testServiceFailUnaryCallHandler.ServeHTTP(w, r)
		case TestServiceCacheableUnaryCallProcedure:
			testServiceCacheableUnaryCallHandler.ServeHTTP(w, r)
		case TestServiceStreamingOutputCallProcedure:
			testServiceStreamingOutputCallHandler.ServeHTTP(w, r)
		case TestServiceFailStreamingOutputCallProcedure:
			testServiceFailStreamingOutputCallHandler.ServeHTTP(w, r)
		case TestServiceStreamingInputCallProcedure:
			testServiceStreamingInputCallHandler.ServeHTTP(w, r)
		case TestServiceFullDuplexCallProcedure:
			testServiceFullDuplexCallHandler.ServeHTTP(w, r)
		case TestServiceHalfDuplexCallProcedure:
			testServiceHalfDuplexCallHandler.ServeHTTP(w, r)
		case TestServiceUnimplementedCallProcedure:
			testServiceUnimplementedCallHandler.ServeHTTP(w, r)
		case TestServiceUnimplementedStreamingOutputCallProcedure:
			testServiceUnimplementedStreamingOutputCallHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedTestServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedTestServiceHandler struct{}

func (UnimplementedTestServiceHandler) EmptyCall(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.TestService.EmptyCall is not implemented"))
}

func (UnimplementedTestServiceHandler) UnaryCall(context.Context, *connect_go.Request[conformance.SimpleRequest]) (*connect_go.Response[conformance.SimpleResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.TestService.UnaryCall is not implemented"))
}

func (UnimplementedTestServiceHandler) FailUnaryCall(context.Context, *connect_go.Request[conformance.SimpleRequest]) (*connect_go.Response[conformance.SimpleResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.TestService.FailUnaryCall is not implemented"))
}

func (UnimplementedTestServiceHandler) CacheableUnaryCall(context.Context, *connect_go.Request[conformance.SimpleRequest]) (*connect_go.Response[conformance.SimpleResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.TestService.CacheableUnaryCall is not implemented"))
}

func (UnimplementedTestServiceHandler) StreamingOutputCall(context.Context, *connect_go.Request[conformance.StreamingOutputCallRequest], *connect_go.ServerStream[conformance.StreamingOutputCallResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.TestService.StreamingOutputCall is not implemented"))
}

func (UnimplementedTestServiceHandler) FailStreamingOutputCall(context.Context, *connect_go.Request[conformance.StreamingOutputCallRequest], *connect_go.ServerStream[conformance.StreamingOutputCallResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.TestService.FailStreamingOutputCall is not implemented"))
}

func (UnimplementedTestServiceHandler) StreamingInputCall(context.Context, *connect_go.ClientStream[conformance.StreamingInputCallRequest]) (*connect_go.Response[conformance.StreamingInputCallResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.TestService.StreamingInputCall is not implemented"))
}

func (UnimplementedTestServiceHandler) FullDuplexCall(context.Context, *connect_go.BidiStream[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.TestService.FullDuplexCall is not implemented"))
}

func (UnimplementedTestServiceHandler) HalfDuplexCall(context.Context, *connect_go.BidiStream[conformance.StreamingOutputCallRequest, conformance.StreamingOutputCallResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.TestService.HalfDuplexCall is not implemented"))
}

func (UnimplementedTestServiceHandler) UnimplementedCall(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.TestService.UnimplementedCall is not implemented"))
}

func (UnimplementedTestServiceHandler) UnimplementedStreamingOutputCall(context.Context, *connect_go.Request[emptypb.Empty], *connect_go.ServerStream[emptypb.Empty]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.TestService.UnimplementedStreamingOutputCall is not implemented"))
}

// UnimplementedServiceClient is a client for the connectrpc.conformance.UnimplementedService
// service.
type UnimplementedServiceClient interface {
	// A call that no server should implement
	UnimplementedCall(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error)
	// A call that no server should implement
	UnimplementedStreamingOutputCall(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.ServerStreamForClient[emptypb.Empty], error)
}

// NewUnimplementedServiceClient constructs a client for the
// connectrpc.conformance.UnimplementedService service. By default, it uses the Connect protocol
// with the binary Protobuf Codec, asks for gzipped responses, and sends uncompressed requests. To
// use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or connect.WithGRPCWeb()
// options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewUnimplementedServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) UnimplementedServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &unimplementedServiceClient{
		unimplementedCall: connect_go.NewClient[emptypb.Empty, emptypb.Empty](
			httpClient,
			baseURL+UnimplementedServiceUnimplementedCallProcedure,
			opts...,
		),
		unimplementedStreamingOutputCall: connect_go.NewClient[emptypb.Empty, emptypb.Empty](
			httpClient,
			baseURL+UnimplementedServiceUnimplementedStreamingOutputCallProcedure,
			opts...,
		),
	}
}

// unimplementedServiceClient implements UnimplementedServiceClient.
type unimplementedServiceClient struct {
	unimplementedCall                *connect_go.Client[emptypb.Empty, emptypb.Empty]
	unimplementedStreamingOutputCall *connect_go.Client[emptypb.Empty, emptypb.Empty]
}

// UnimplementedCall calls connectrpc.conformance.UnimplementedService.UnimplementedCall.
func (c *unimplementedServiceClient) UnimplementedCall(ctx context.Context, req *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error) {
	return c.unimplementedCall.CallUnary(ctx, req)
}

// UnimplementedStreamingOutputCall calls
// connectrpc.conformance.UnimplementedService.UnimplementedStreamingOutputCall.
func (c *unimplementedServiceClient) UnimplementedStreamingOutputCall(ctx context.Context, req *connect_go.Request[emptypb.Empty]) (*connect_go.ServerStreamForClient[emptypb.Empty], error) {
	return c.unimplementedStreamingOutputCall.CallServerStream(ctx, req)
}

// UnimplementedServiceHandler is an implementation of the
// connectrpc.conformance.UnimplementedService service.
type UnimplementedServiceHandler interface {
	// A call that no server should implement
	UnimplementedCall(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error)
	// A call that no server should implement
	UnimplementedStreamingOutputCall(context.Context, *connect_go.Request[emptypb.Empty], *connect_go.ServerStream[emptypb.Empty]) error
}

// NewUnimplementedServiceHandler builds an HTTP handler from the service implementation. It returns
// the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewUnimplementedServiceHandler(svc UnimplementedServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	unimplementedServiceUnimplementedCallHandler := connect_go.NewUnaryHandler(
		UnimplementedServiceUnimplementedCallProcedure,
		svc.UnimplementedCall,
		opts...,
	)
	unimplementedServiceUnimplementedStreamingOutputCallHandler := connect_go.NewServerStreamHandler(
		UnimplementedServiceUnimplementedStreamingOutputCallProcedure,
		svc.UnimplementedStreamingOutputCall,
		opts...,
	)
	return "/connectrpc.conformance.UnimplementedService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case UnimplementedServiceUnimplementedCallProcedure:
			unimplementedServiceUnimplementedCallHandler.ServeHTTP(w, r)
		case UnimplementedServiceUnimplementedStreamingOutputCallProcedure:
			unimplementedServiceUnimplementedStreamingOutputCallHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedUnimplementedServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedUnimplementedServiceHandler struct{}

func (UnimplementedUnimplementedServiceHandler) UnimplementedCall(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.UnimplementedService.UnimplementedCall is not implemented"))
}

func (UnimplementedUnimplementedServiceHandler) UnimplementedStreamingOutputCall(context.Context, *connect_go.Request[emptypb.Empty], *connect_go.ServerStream[emptypb.Empty]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.UnimplementedService.UnimplementedStreamingOutputCall is not implemented"))
}

// ReconnectServiceClient is a client for the connectrpc.conformance.ReconnectService service.
type ReconnectServiceClient interface {
	Start(context.Context, *connect_go.Request[conformance.ReconnectParams]) (*connect_go.Response[emptypb.Empty], error)
	Stop(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[conformance.ReconnectInfo], error)
}

// NewReconnectServiceClient constructs a client for the connectrpc.conformance.ReconnectService
// service. By default, it uses the Connect protocol with the binary Protobuf Codec, asks for
// gzipped responses, and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply
// the connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewReconnectServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) ReconnectServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &reconnectServiceClient{
		start: connect_go.NewClient[conformance.ReconnectParams, emptypb.Empty](
			httpClient,
			baseURL+ReconnectServiceStartProcedure,
			opts...,
		),
		stop: connect_go.NewClient[emptypb.Empty, conformance.ReconnectInfo](
			httpClient,
			baseURL+ReconnectServiceStopProcedure,
			opts...,
		),
	}
}

// reconnectServiceClient implements ReconnectServiceClient.
type reconnectServiceClient struct {
	start *connect_go.Client[conformance.ReconnectParams, emptypb.Empty]
	stop  *connect_go.Client[emptypb.Empty, conformance.ReconnectInfo]
}

// Start calls connectrpc.conformance.ReconnectService.Start.
func (c *reconnectServiceClient) Start(ctx context.Context, req *connect_go.Request[conformance.ReconnectParams]) (*connect_go.Response[emptypb.Empty], error) {
	return c.start.CallUnary(ctx, req)
}

// Stop calls connectrpc.conformance.ReconnectService.Stop.
func (c *reconnectServiceClient) Stop(ctx context.Context, req *connect_go.Request[emptypb.Empty]) (*connect_go.Response[conformance.ReconnectInfo], error) {
	return c.stop.CallUnary(ctx, req)
}

// ReconnectServiceHandler is an implementation of the connectrpc.conformance.ReconnectService
// service.
type ReconnectServiceHandler interface {
	Start(context.Context, *connect_go.Request[conformance.ReconnectParams]) (*connect_go.Response[emptypb.Empty], error)
	Stop(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[conformance.ReconnectInfo], error)
}

// NewReconnectServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewReconnectServiceHandler(svc ReconnectServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	reconnectServiceStartHandler := connect_go.NewUnaryHandler(
		ReconnectServiceStartProcedure,
		svc.Start,
		opts...,
	)
	reconnectServiceStopHandler := connect_go.NewUnaryHandler(
		ReconnectServiceStopProcedure,
		svc.Stop,
		opts...,
	)
	return "/connectrpc.conformance.ReconnectService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case ReconnectServiceStartProcedure:
			reconnectServiceStartHandler.ServeHTTP(w, r)
		case ReconnectServiceStopProcedure:
			reconnectServiceStopHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedReconnectServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedReconnectServiceHandler struct{}

func (UnimplementedReconnectServiceHandler) Start(context.Context, *connect_go.Request[conformance.ReconnectParams]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.ReconnectService.Start is not implemented"))
}

func (UnimplementedReconnectServiceHandler) Stop(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[conformance.ReconnectInfo], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.ReconnectService.Stop is not implemented"))
}

// LoadBalancerStatsServiceClient is a client for the
// connectrpc.conformance.LoadBalancerStatsService service.
type LoadBalancerStatsServiceClient interface {
	// Gets the backend distribution for RPCs sent by a test client.
	GetClientStats(context.Context, *connect_go.Request[conformance.LoadBalancerStatsRequest]) (*connect_go.Response[conformance.LoadBalancerStatsResponse], error)
	// Gets the accumulated stats for RPCs sent by a test client.
	GetClientAccumulatedStats(context.Context, *connect_go.Request[conformance.LoadBalancerAccumulatedStatsRequest]) (*connect_go.Response[conformance.LoadBalancerAccumulatedStatsResponse], error)
}

// NewLoadBalancerStatsServiceClient constructs a client for the
// connectrpc.conformance.LoadBalancerStatsService service. By default, it uses the Connect protocol
// with the binary Protobuf Codec, asks for gzipped responses, and sends uncompressed requests. To
// use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or connect.WithGRPCWeb()
// options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewLoadBalancerStatsServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) LoadBalancerStatsServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &loadBalancerStatsServiceClient{
		getClientStats: connect_go.NewClient[conformance.LoadBalancerStatsRequest, conformance.LoadBalancerStatsResponse](
			httpClient,
			baseURL+LoadBalancerStatsServiceGetClientStatsProcedure,
			opts...,
		),
		getClientAccumulatedStats: connect_go.NewClient[conformance.LoadBalancerAccumulatedStatsRequest, conformance.LoadBalancerAccumulatedStatsResponse](
			httpClient,
			baseURL+LoadBalancerStatsServiceGetClientAccumulatedStatsProcedure,
			opts...,
		),
	}
}

// loadBalancerStatsServiceClient implements LoadBalancerStatsServiceClient.
type loadBalancerStatsServiceClient struct {
	getClientStats            *connect_go.Client[conformance.LoadBalancerStatsRequest, conformance.LoadBalancerStatsResponse]
	getClientAccumulatedStats *connect_go.Client[conformance.LoadBalancerAccumulatedStatsRequest, conformance.LoadBalancerAccumulatedStatsResponse]
}

// GetClientStats calls connectrpc.conformance.LoadBalancerStatsService.GetClientStats.
func (c *loadBalancerStatsServiceClient) GetClientStats(ctx context.Context, req *connect_go.Request[conformance.LoadBalancerStatsRequest]) (*connect_go.Response[conformance.LoadBalancerStatsResponse], error) {
	return c.getClientStats.CallUnary(ctx, req)
}

// GetClientAccumulatedStats calls
// connectrpc.conformance.LoadBalancerStatsService.GetClientAccumulatedStats.
func (c *loadBalancerStatsServiceClient) GetClientAccumulatedStats(ctx context.Context, req *connect_go.Request[conformance.LoadBalancerAccumulatedStatsRequest]) (*connect_go.Response[conformance.LoadBalancerAccumulatedStatsResponse], error) {
	return c.getClientAccumulatedStats.CallUnary(ctx, req)
}

// LoadBalancerStatsServiceHandler is an implementation of the
// connectrpc.conformance.LoadBalancerStatsService service.
type LoadBalancerStatsServiceHandler interface {
	// Gets the backend distribution for RPCs sent by a test client.
	GetClientStats(context.Context, *connect_go.Request[conformance.LoadBalancerStatsRequest]) (*connect_go.Response[conformance.LoadBalancerStatsResponse], error)
	// Gets the accumulated stats for RPCs sent by a test client.
	GetClientAccumulatedStats(context.Context, *connect_go.Request[conformance.LoadBalancerAccumulatedStatsRequest]) (*connect_go.Response[conformance.LoadBalancerAccumulatedStatsResponse], error)
}

// NewLoadBalancerStatsServiceHandler builds an HTTP handler from the service implementation. It
// returns the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewLoadBalancerStatsServiceHandler(svc LoadBalancerStatsServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	loadBalancerStatsServiceGetClientStatsHandler := connect_go.NewUnaryHandler(
		LoadBalancerStatsServiceGetClientStatsProcedure,
		svc.GetClientStats,
		opts...,
	)
	loadBalancerStatsServiceGetClientAccumulatedStatsHandler := connect_go.NewUnaryHandler(
		LoadBalancerStatsServiceGetClientAccumulatedStatsProcedure,
		svc.GetClientAccumulatedStats,
		opts...,
	)
	return "/connectrpc.conformance.LoadBalancerStatsService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case LoadBalancerStatsServiceGetClientStatsProcedure:
			loadBalancerStatsServiceGetClientStatsHandler.ServeHTTP(w, r)
		case LoadBalancerStatsServiceGetClientAccumulatedStatsProcedure:
			loadBalancerStatsServiceGetClientAccumulatedStatsHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedLoadBalancerStatsServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedLoadBalancerStatsServiceHandler struct{}

func (UnimplementedLoadBalancerStatsServiceHandler) GetClientStats(context.Context, *connect_go.Request[conformance.LoadBalancerStatsRequest]) (*connect_go.Response[conformance.LoadBalancerStatsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.LoadBalancerStatsService.GetClientStats is not implemented"))
}

func (UnimplementedLoadBalancerStatsServiceHandler) GetClientAccumulatedStats(context.Context, *connect_go.Request[conformance.LoadBalancerAccumulatedStatsRequest]) (*connect_go.Response[conformance.LoadBalancerAccumulatedStatsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.LoadBalancerStatsService.GetClientAccumulatedStats is not implemented"))
}

// XdsUpdateHealthServiceClient is a client for the connectrpc.conformance.XdsUpdateHealthService
// service.
type XdsUpdateHealthServiceClient interface {
	SetServing(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error)
	SetNotServing(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error)
}

// NewXdsUpdateHealthServiceClient constructs a client for the
// connectrpc.conformance.XdsUpdateHealthService service. By default, it uses the Connect protocol
// with the binary Protobuf Codec, asks for gzipped responses, and sends uncompressed requests. To
// use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or connect.WithGRPCWeb()
// options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewXdsUpdateHealthServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) XdsUpdateHealthServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &xdsUpdateHealthServiceClient{
		setServing: connect_go.NewClient[emptypb.Empty, emptypb.Empty](
			httpClient,
			baseURL+XdsUpdateHealthServiceSetServingProcedure,
			opts...,
		),
		setNotServing: connect_go.NewClient[emptypb.Empty, emptypb.Empty](
			httpClient,
			baseURL+XdsUpdateHealthServiceSetNotServingProcedure,
			opts...,
		),
	}
}

// xdsUpdateHealthServiceClient implements XdsUpdateHealthServiceClient.
type xdsUpdateHealthServiceClient struct {
	setServing    *connect_go.Client[emptypb.Empty, emptypb.Empty]
	setNotServing *connect_go.Client[emptypb.Empty, emptypb.Empty]
}

// SetServing calls connectrpc.conformance.XdsUpdateHealthService.SetServing.
func (c *xdsUpdateHealthServiceClient) SetServing(ctx context.Context, req *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error) {
	return c.setServing.CallUnary(ctx, req)
}

// SetNotServing calls connectrpc.conformance.XdsUpdateHealthService.SetNotServing.
func (c *xdsUpdateHealthServiceClient) SetNotServing(ctx context.Context, req *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error) {
	return c.setNotServing.CallUnary(ctx, req)
}

// XdsUpdateHealthServiceHandler is an implementation of the
// connectrpc.conformance.XdsUpdateHealthService service.
type XdsUpdateHealthServiceHandler interface {
	SetServing(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error)
	SetNotServing(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error)
}

// NewXdsUpdateHealthServiceHandler builds an HTTP handler from the service implementation. It
// returns the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewXdsUpdateHealthServiceHandler(svc XdsUpdateHealthServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	xdsUpdateHealthServiceSetServingHandler := connect_go.NewUnaryHandler(
		XdsUpdateHealthServiceSetServingProcedure,
		svc.SetServing,
		opts...,
	)
	xdsUpdateHealthServiceSetNotServingHandler := connect_go.NewUnaryHandler(
		XdsUpdateHealthServiceSetNotServingProcedure,
		svc.SetNotServing,
		opts...,
	)
	return "/connectrpc.conformance.XdsUpdateHealthService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case XdsUpdateHealthServiceSetServingProcedure:
			xdsUpdateHealthServiceSetServingHandler.ServeHTTP(w, r)
		case XdsUpdateHealthServiceSetNotServingProcedure:
			xdsUpdateHealthServiceSetNotServingHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedXdsUpdateHealthServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedXdsUpdateHealthServiceHandler struct{}

func (UnimplementedXdsUpdateHealthServiceHandler) SetServing(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.XdsUpdateHealthService.SetServing is not implemented"))
}

func (UnimplementedXdsUpdateHealthServiceHandler) SetNotServing(context.Context, *connect_go.Request[emptypb.Empty]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.XdsUpdateHealthService.SetNotServing is not implemented"))
}

// XdsUpdateClientConfigureServiceClient is a client for the
// connectrpc.conformance.XdsUpdateClientConfigureService service.
type XdsUpdateClientConfigureServiceClient interface {
	// Update the tes client's configuration.
	Configure(context.Context, *connect_go.Request[conformance.ClientConfigureRequest]) (*connect_go.Response[conformance.ClientConfigureResponse], error)
}

// NewXdsUpdateClientConfigureServiceClient constructs a client for the
// connectrpc.conformance.XdsUpdateClientConfigureService service. By default, it uses the Connect
// protocol with the binary Protobuf Codec, asks for gzipped responses, and sends uncompressed
// requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewXdsUpdateClientConfigureServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) XdsUpdateClientConfigureServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &xdsUpdateClientConfigureServiceClient{
		configure: connect_go.NewClient[conformance.ClientConfigureRequest, conformance.ClientConfigureResponse](
			httpClient,
			baseURL+XdsUpdateClientConfigureServiceConfigureProcedure,
			opts...,
		),
	}
}

// xdsUpdateClientConfigureServiceClient implements XdsUpdateClientConfigureServiceClient.
type xdsUpdateClientConfigureServiceClient struct {
	configure *connect_go.Client[conformance.ClientConfigureRequest, conformance.ClientConfigureResponse]
}

// Configure calls connectrpc.conformance.XdsUpdateClientConfigureService.Configure.
func (c *xdsUpdateClientConfigureServiceClient) Configure(ctx context.Context, req *connect_go.Request[conformance.ClientConfigureRequest]) (*connect_go.Response[conformance.ClientConfigureResponse], error) {
	return c.configure.CallUnary(ctx, req)
}

// XdsUpdateClientConfigureServiceHandler is an implementation of the
// connectrpc.conformance.XdsUpdateClientConfigureService service.
type XdsUpdateClientConfigureServiceHandler interface {
	// Update the tes client's configuration.
	Configure(context.Context, *connect_go.Request[conformance.ClientConfigureRequest]) (*connect_go.Response[conformance.ClientConfigureResponse], error)
}

// NewXdsUpdateClientConfigureServiceHandler builds an HTTP handler from the service implementation.
// It returns the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewXdsUpdateClientConfigureServiceHandler(svc XdsUpdateClientConfigureServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	xdsUpdateClientConfigureServiceConfigureHandler := connect_go.NewUnaryHandler(
		XdsUpdateClientConfigureServiceConfigureProcedure,
		svc.Configure,
		opts...,
	)
	return "/connectrpc.conformance.XdsUpdateClientConfigureService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case XdsUpdateClientConfigureServiceConfigureProcedure:
			xdsUpdateClientConfigureServiceConfigureHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedXdsUpdateClientConfigureServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedXdsUpdateClientConfigureServiceHandler struct{}

func (UnimplementedXdsUpdateClientConfigureServiceHandler) Configure(context.Context, *connect_go.Request[conformance.ClientConfigureRequest]) (*connect_go.Response[conformance.ClientConfigureResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("connectrpc.conformance.XdsUpdateClientConfigureService.Configure is not implemented"))
}
