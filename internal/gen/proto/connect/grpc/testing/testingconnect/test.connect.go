// Copyright 2022 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: grpc/testing/test.proto

package testingconnect

import (
	context "context"
	errors "errors"
	testing "github.com/bufbuild/connect-crosstest/internal/gen/proto/go/grpc/testing"
	connect_go "github.com/bufbuild/connect-go"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion0_1_0

const (
	// TestServiceName is the fully-qualified name of the TestService service.
	TestServiceName = "grpc.testing.TestService"
	// UnimplementedServiceName is the fully-qualified name of the UnimplementedService service.
	UnimplementedServiceName = "grpc.testing.UnimplementedService"
	// ReconnectServiceName is the fully-qualified name of the ReconnectService service.
	ReconnectServiceName = "grpc.testing.ReconnectService"
	// LoadBalancerStatsServiceName is the fully-qualified name of the LoadBalancerStatsService service.
	LoadBalancerStatsServiceName = "grpc.testing.LoadBalancerStatsService"
	// XdsUpdateHealthServiceName is the fully-qualified name of the XdsUpdateHealthService service.
	XdsUpdateHealthServiceName = "grpc.testing.XdsUpdateHealthService"
	// XdsUpdateClientConfigureServiceName is the fully-qualified name of the
	// XdsUpdateClientConfigureService service.
	XdsUpdateClientConfigureServiceName = "grpc.testing.XdsUpdateClientConfigureService"
)

// TestServiceClient is a client for the grpc.testing.TestService service.
type TestServiceClient interface {
	// One empty request followed by one empty response.
	EmptyCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
	// One request followed by one response.
	UnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error)
	// One request followed by one response. This RPC always fails.
	FailUnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error)
	// One request followed by one response. Response has cache control
	// headers set such that a caching HTTP proxy (such as GFE) can
	// satisfy subsequent requests.
	CacheableUnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error)
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	StreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest]) (*connect_go.ServerStreamForClient[testing.StreamingOutputCallResponse], error)
	// One request followed by a sequence of responses (streamed download). This RPC always fails.
	FailStreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest]) (*connect_go.ServerStreamForClient[testing.StreamingOutputCallResponse], error)
	// A sequence of requests followed by one response (streamed upload).
	// The server returns the aggregated size of client payload as the result.
	StreamingInputCall(context.Context) *connect_go.ClientStreamForClient[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse]
	// A sequence of requests with each request served by the server immediately.
	// As one request could lead to multiple responses, this interface
	// demonstrates the idea of full duplexing.
	FullDuplexCall(context.Context) *connect_go.BidiStreamForClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client requests and then serves them in order. A
	// stream of responses are returned to the client when the server starts with
	// first request.
	HalfDuplexCall(context.Context) *connect_go.BidiStreamForClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented methods.
	UnimplementedCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
}

// NewTestServiceClient constructs a client for the grpc.testing.TestService service. By default, it
// uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewTestServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) TestServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &testServiceClient{
		emptyCall: connect_go.NewClient[testing.Empty, testing.Empty](
			httpClient,
			baseURL+"/grpc.testing.TestService/EmptyCall",
			opts...,
		),
		unaryCall: connect_go.NewClient[testing.SimpleRequest, testing.SimpleResponse](
			httpClient,
			baseURL+"/grpc.testing.TestService/UnaryCall",
			opts...,
		),
		failUnaryCall: connect_go.NewClient[testing.SimpleRequest, testing.SimpleResponse](
			httpClient,
			baseURL+"/grpc.testing.TestService/FailUnaryCall",
			opts...,
		),
		cacheableUnaryCall: connect_go.NewClient[testing.SimpleRequest, testing.SimpleResponse](
			httpClient,
			baseURL+"/grpc.testing.TestService/CacheableUnaryCall",
			opts...,
		),
		streamingOutputCall: connect_go.NewClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](
			httpClient,
			baseURL+"/grpc.testing.TestService/StreamingOutputCall",
			opts...,
		),
		failStreamingOutputCall: connect_go.NewClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](
			httpClient,
			baseURL+"/grpc.testing.TestService/FailStreamingOutputCall",
			opts...,
		),
		streamingInputCall: connect_go.NewClient[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse](
			httpClient,
			baseURL+"/grpc.testing.TestService/StreamingInputCall",
			opts...,
		),
		fullDuplexCall: connect_go.NewClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](
			httpClient,
			baseURL+"/grpc.testing.TestService/FullDuplexCall",
			opts...,
		),
		halfDuplexCall: connect_go.NewClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](
			httpClient,
			baseURL+"/grpc.testing.TestService/HalfDuplexCall",
			opts...,
		),
		unimplementedCall: connect_go.NewClient[testing.Empty, testing.Empty](
			httpClient,
			baseURL+"/grpc.testing.TestService/UnimplementedCall",
			opts...,
		),
	}
}

// testServiceClient implements TestServiceClient.
type testServiceClient struct {
	emptyCall               *connect_go.Client[testing.Empty, testing.Empty]
	unaryCall               *connect_go.Client[testing.SimpleRequest, testing.SimpleResponse]
	failUnaryCall           *connect_go.Client[testing.SimpleRequest, testing.SimpleResponse]
	cacheableUnaryCall      *connect_go.Client[testing.SimpleRequest, testing.SimpleResponse]
	streamingOutputCall     *connect_go.Client[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	failStreamingOutputCall *connect_go.Client[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	streamingInputCall      *connect_go.Client[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse]
	fullDuplexCall          *connect_go.Client[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	halfDuplexCall          *connect_go.Client[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	unimplementedCall       *connect_go.Client[testing.Empty, testing.Empty]
}

// EmptyCall calls grpc.testing.TestService.EmptyCall.
func (c *testServiceClient) EmptyCall(ctx context.Context, req *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return c.emptyCall.CallUnary(ctx, req)
}

// UnaryCall calls grpc.testing.TestService.UnaryCall.
func (c *testServiceClient) UnaryCall(ctx context.Context, req *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error) {
	return c.unaryCall.CallUnary(ctx, req)
}

// FailUnaryCall calls grpc.testing.TestService.FailUnaryCall.
func (c *testServiceClient) FailUnaryCall(ctx context.Context, req *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error) {
	return c.failUnaryCall.CallUnary(ctx, req)
}

// CacheableUnaryCall calls grpc.testing.TestService.CacheableUnaryCall.
func (c *testServiceClient) CacheableUnaryCall(ctx context.Context, req *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error) {
	return c.cacheableUnaryCall.CallUnary(ctx, req)
}

// StreamingOutputCall calls grpc.testing.TestService.StreamingOutputCall.
func (c *testServiceClient) StreamingOutputCall(ctx context.Context, req *connect_go.Request[testing.StreamingOutputCallRequest]) (*connect_go.ServerStreamForClient[testing.StreamingOutputCallResponse], error) {
	return c.streamingOutputCall.CallServerStream(ctx, req)
}

// FailStreamingOutputCall calls grpc.testing.TestService.FailStreamingOutputCall.
func (c *testServiceClient) FailStreamingOutputCall(ctx context.Context, req *connect_go.Request[testing.StreamingOutputCallRequest]) (*connect_go.ServerStreamForClient[testing.StreamingOutputCallResponse], error) {
	return c.failStreamingOutputCall.CallServerStream(ctx, req)
}

// StreamingInputCall calls grpc.testing.TestService.StreamingInputCall.
func (c *testServiceClient) StreamingInputCall(ctx context.Context) *connect_go.ClientStreamForClient[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse] {
	return c.streamingInputCall.CallClientStream(ctx)
}

// FullDuplexCall calls grpc.testing.TestService.FullDuplexCall.
func (c *testServiceClient) FullDuplexCall(ctx context.Context) *connect_go.BidiStreamForClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse] {
	return c.fullDuplexCall.CallBidiStream(ctx)
}

// HalfDuplexCall calls grpc.testing.TestService.HalfDuplexCall.
func (c *testServiceClient) HalfDuplexCall(ctx context.Context) *connect_go.BidiStreamForClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse] {
	return c.halfDuplexCall.CallBidiStream(ctx)
}

// UnimplementedCall calls grpc.testing.TestService.UnimplementedCall.
func (c *testServiceClient) UnimplementedCall(ctx context.Context, req *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return c.unimplementedCall.CallUnary(ctx, req)
}

// TestServiceHandler is an implementation of the grpc.testing.TestService service.
type TestServiceHandler interface {
	// One empty request followed by one empty response.
	EmptyCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
	// One request followed by one response.
	UnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error)
	// One request followed by one response. This RPC always fails.
	FailUnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error)
	// One request followed by one response. Response has cache control
	// headers set such that a caching HTTP proxy (such as GFE) can
	// satisfy subsequent requests.
	CacheableUnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error)
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	StreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest], *connect_go.ServerStream[testing.StreamingOutputCallResponse]) error
	// One request followed by a sequence of responses (streamed download). This RPC always fails.
	FailStreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest], *connect_go.ServerStream[testing.StreamingOutputCallResponse]) error
	// A sequence of requests followed by one response (streamed upload).
	// The server returns the aggregated size of client payload as the result.
	StreamingInputCall(context.Context, *connect_go.ClientStream[testing.StreamingInputCallRequest]) (*connect_go.Response[testing.StreamingInputCallResponse], error)
	// A sequence of requests with each request served by the server immediately.
	// As one request could lead to multiple responses, this interface
	// demonstrates the idea of full duplexing.
	FullDuplexCall(context.Context, *connect_go.BidiStream[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error
	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client requests and then serves them in order. A
	// stream of responses are returned to the client when the server starts with
	// first request.
	HalfDuplexCall(context.Context, *connect_go.BidiStream[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error
	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented methods.
	UnimplementedCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
}

// NewTestServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewTestServiceHandler(svc TestServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/grpc.testing.TestService/EmptyCall", connect_go.NewUnaryHandler(
		"/grpc.testing.TestService/EmptyCall",
		svc.EmptyCall,
		opts...,
	))
	mux.Handle("/grpc.testing.TestService/UnaryCall", connect_go.NewUnaryHandler(
		"/grpc.testing.TestService/UnaryCall",
		svc.UnaryCall,
		opts...,
	))
	mux.Handle("/grpc.testing.TestService/FailUnaryCall", connect_go.NewUnaryHandler(
		"/grpc.testing.TestService/FailUnaryCall",
		svc.FailUnaryCall,
		opts...,
	))
	mux.Handle("/grpc.testing.TestService/CacheableUnaryCall", connect_go.NewUnaryHandler(
		"/grpc.testing.TestService/CacheableUnaryCall",
		svc.CacheableUnaryCall,
		opts...,
	))
	mux.Handle("/grpc.testing.TestService/StreamingOutputCall", connect_go.NewServerStreamHandler(
		"/grpc.testing.TestService/StreamingOutputCall",
		svc.StreamingOutputCall,
		opts...,
	))
	mux.Handle("/grpc.testing.TestService/FailStreamingOutputCall", connect_go.NewServerStreamHandler(
		"/grpc.testing.TestService/FailStreamingOutputCall",
		svc.FailStreamingOutputCall,
		opts...,
	))
	mux.Handle("/grpc.testing.TestService/StreamingInputCall", connect_go.NewClientStreamHandler(
		"/grpc.testing.TestService/StreamingInputCall",
		svc.StreamingInputCall,
		opts...,
	))
	mux.Handle("/grpc.testing.TestService/FullDuplexCall", connect_go.NewBidiStreamHandler(
		"/grpc.testing.TestService/FullDuplexCall",
		svc.FullDuplexCall,
		opts...,
	))
	mux.Handle("/grpc.testing.TestService/HalfDuplexCall", connect_go.NewBidiStreamHandler(
		"/grpc.testing.TestService/HalfDuplexCall",
		svc.HalfDuplexCall,
		opts...,
	))
	mux.Handle("/grpc.testing.TestService/UnimplementedCall", connect_go.NewUnaryHandler(
		"/grpc.testing.TestService/UnimplementedCall",
		svc.UnimplementedCall,
		opts...,
	))
	return "/grpc.testing.TestService/", mux
}

// UnimplementedTestServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedTestServiceHandler struct{}

func (UnimplementedTestServiceHandler) EmptyCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.EmptyCall is not implemented"))
}

func (UnimplementedTestServiceHandler) UnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.UnaryCall is not implemented"))
}

func (UnimplementedTestServiceHandler) FailUnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.FailUnaryCall is not implemented"))
}

func (UnimplementedTestServiceHandler) CacheableUnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.CacheableUnaryCall is not implemented"))
}

func (UnimplementedTestServiceHandler) StreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest], *connect_go.ServerStream[testing.StreamingOutputCallResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.StreamingOutputCall is not implemented"))
}

func (UnimplementedTestServiceHandler) FailStreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest], *connect_go.ServerStream[testing.StreamingOutputCallResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.FailStreamingOutputCall is not implemented"))
}

func (UnimplementedTestServiceHandler) StreamingInputCall(context.Context, *connect_go.ClientStream[testing.StreamingInputCallRequest]) (*connect_go.Response[testing.StreamingInputCallResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.StreamingInputCall is not implemented"))
}

func (UnimplementedTestServiceHandler) FullDuplexCall(context.Context, *connect_go.BidiStream[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.FullDuplexCall is not implemented"))
}

func (UnimplementedTestServiceHandler) HalfDuplexCall(context.Context, *connect_go.BidiStream[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.HalfDuplexCall is not implemented"))
}

func (UnimplementedTestServiceHandler) UnimplementedCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.UnimplementedCall is not implemented"))
}

// UnimplementedServiceClient is a client for the grpc.testing.UnimplementedService service.
type UnimplementedServiceClient interface {
	// A call that no server should implement
	UnimplementedCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
}

// NewUnimplementedServiceClient constructs a client for the grpc.testing.UnimplementedService
// service. By default, it uses the Connect protocol with the binary Protobuf Codec, asks for
// gzipped responses, and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply
// the connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewUnimplementedServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) UnimplementedServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &unimplementedServiceClient{
		unimplementedCall: connect_go.NewClient[testing.Empty, testing.Empty](
			httpClient,
			baseURL+"/grpc.testing.UnimplementedService/UnimplementedCall",
			opts...,
		),
	}
}

// unimplementedServiceClient implements UnimplementedServiceClient.
type unimplementedServiceClient struct {
	unimplementedCall *connect_go.Client[testing.Empty, testing.Empty]
}

// UnimplementedCall calls grpc.testing.UnimplementedService.UnimplementedCall.
func (c *unimplementedServiceClient) UnimplementedCall(ctx context.Context, req *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return c.unimplementedCall.CallUnary(ctx, req)
}

// UnimplementedServiceHandler is an implementation of the grpc.testing.UnimplementedService
// service.
type UnimplementedServiceHandler interface {
	// A call that no server should implement
	UnimplementedCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
}

// NewUnimplementedServiceHandler builds an HTTP handler from the service implementation. It returns
// the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewUnimplementedServiceHandler(svc UnimplementedServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/grpc.testing.UnimplementedService/UnimplementedCall", connect_go.NewUnaryHandler(
		"/grpc.testing.UnimplementedService/UnimplementedCall",
		svc.UnimplementedCall,
		opts...,
	))
	return "/grpc.testing.UnimplementedService/", mux
}

// UnimplementedUnimplementedServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedUnimplementedServiceHandler struct{}

func (UnimplementedUnimplementedServiceHandler) UnimplementedCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.UnimplementedService.UnimplementedCall is not implemented"))
}

// ReconnectServiceClient is a client for the grpc.testing.ReconnectService service.
type ReconnectServiceClient interface {
	Start(context.Context, *connect_go.Request[testing.ReconnectParams]) (*connect_go.Response[testing.Empty], error)
	Stop(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.ReconnectInfo], error)
}

// NewReconnectServiceClient constructs a client for the grpc.testing.ReconnectService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewReconnectServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) ReconnectServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &reconnectServiceClient{
		start: connect_go.NewClient[testing.ReconnectParams, testing.Empty](
			httpClient,
			baseURL+"/grpc.testing.ReconnectService/Start",
			opts...,
		),
		stop: connect_go.NewClient[testing.Empty, testing.ReconnectInfo](
			httpClient,
			baseURL+"/grpc.testing.ReconnectService/Stop",
			opts...,
		),
	}
}

// reconnectServiceClient implements ReconnectServiceClient.
type reconnectServiceClient struct {
	start *connect_go.Client[testing.ReconnectParams, testing.Empty]
	stop  *connect_go.Client[testing.Empty, testing.ReconnectInfo]
}

// Start calls grpc.testing.ReconnectService.Start.
func (c *reconnectServiceClient) Start(ctx context.Context, req *connect_go.Request[testing.ReconnectParams]) (*connect_go.Response[testing.Empty], error) {
	return c.start.CallUnary(ctx, req)
}

// Stop calls grpc.testing.ReconnectService.Stop.
func (c *reconnectServiceClient) Stop(ctx context.Context, req *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.ReconnectInfo], error) {
	return c.stop.CallUnary(ctx, req)
}

// ReconnectServiceHandler is an implementation of the grpc.testing.ReconnectService service.
type ReconnectServiceHandler interface {
	Start(context.Context, *connect_go.Request[testing.ReconnectParams]) (*connect_go.Response[testing.Empty], error)
	Stop(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.ReconnectInfo], error)
}

// NewReconnectServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewReconnectServiceHandler(svc ReconnectServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/grpc.testing.ReconnectService/Start", connect_go.NewUnaryHandler(
		"/grpc.testing.ReconnectService/Start",
		svc.Start,
		opts...,
	))
	mux.Handle("/grpc.testing.ReconnectService/Stop", connect_go.NewUnaryHandler(
		"/grpc.testing.ReconnectService/Stop",
		svc.Stop,
		opts...,
	))
	return "/grpc.testing.ReconnectService/", mux
}

// UnimplementedReconnectServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedReconnectServiceHandler struct{}

func (UnimplementedReconnectServiceHandler) Start(context.Context, *connect_go.Request[testing.ReconnectParams]) (*connect_go.Response[testing.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.ReconnectService.Start is not implemented"))
}

func (UnimplementedReconnectServiceHandler) Stop(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.ReconnectInfo], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.ReconnectService.Stop is not implemented"))
}

// LoadBalancerStatsServiceClient is a client for the grpc.testing.LoadBalancerStatsService service.
type LoadBalancerStatsServiceClient interface {
	// Gets the backend distribution for RPCs sent by a test client.
	GetClientStats(context.Context, *connect_go.Request[testing.LoadBalancerStatsRequest]) (*connect_go.Response[testing.LoadBalancerStatsResponse], error)
	// Gets the accumulated stats for RPCs sent by a test client.
	GetClientAccumulatedStats(context.Context, *connect_go.Request[testing.LoadBalancerAccumulatedStatsRequest]) (*connect_go.Response[testing.LoadBalancerAccumulatedStatsResponse], error)
}

// NewLoadBalancerStatsServiceClient constructs a client for the
// grpc.testing.LoadBalancerStatsService service. By default, it uses the Connect protocol with the
// binary Protobuf Codec, asks for gzipped responses, and sends uncompressed requests. To use the
// gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewLoadBalancerStatsServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) LoadBalancerStatsServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &loadBalancerStatsServiceClient{
		getClientStats: connect_go.NewClient[testing.LoadBalancerStatsRequest, testing.LoadBalancerStatsResponse](
			httpClient,
			baseURL+"/grpc.testing.LoadBalancerStatsService/GetClientStats",
			opts...,
		),
		getClientAccumulatedStats: connect_go.NewClient[testing.LoadBalancerAccumulatedStatsRequest, testing.LoadBalancerAccumulatedStatsResponse](
			httpClient,
			baseURL+"/grpc.testing.LoadBalancerStatsService/GetClientAccumulatedStats",
			opts...,
		),
	}
}

// loadBalancerStatsServiceClient implements LoadBalancerStatsServiceClient.
type loadBalancerStatsServiceClient struct {
	getClientStats            *connect_go.Client[testing.LoadBalancerStatsRequest, testing.LoadBalancerStatsResponse]
	getClientAccumulatedStats *connect_go.Client[testing.LoadBalancerAccumulatedStatsRequest, testing.LoadBalancerAccumulatedStatsResponse]
}

// GetClientStats calls grpc.testing.LoadBalancerStatsService.GetClientStats.
func (c *loadBalancerStatsServiceClient) GetClientStats(ctx context.Context, req *connect_go.Request[testing.LoadBalancerStatsRequest]) (*connect_go.Response[testing.LoadBalancerStatsResponse], error) {
	return c.getClientStats.CallUnary(ctx, req)
}

// GetClientAccumulatedStats calls grpc.testing.LoadBalancerStatsService.GetClientAccumulatedStats.
func (c *loadBalancerStatsServiceClient) GetClientAccumulatedStats(ctx context.Context, req *connect_go.Request[testing.LoadBalancerAccumulatedStatsRequest]) (*connect_go.Response[testing.LoadBalancerAccumulatedStatsResponse], error) {
	return c.getClientAccumulatedStats.CallUnary(ctx, req)
}

// LoadBalancerStatsServiceHandler is an implementation of the grpc.testing.LoadBalancerStatsService
// service.
type LoadBalancerStatsServiceHandler interface {
	// Gets the backend distribution for RPCs sent by a test client.
	GetClientStats(context.Context, *connect_go.Request[testing.LoadBalancerStatsRequest]) (*connect_go.Response[testing.LoadBalancerStatsResponse], error)
	// Gets the accumulated stats for RPCs sent by a test client.
	GetClientAccumulatedStats(context.Context, *connect_go.Request[testing.LoadBalancerAccumulatedStatsRequest]) (*connect_go.Response[testing.LoadBalancerAccumulatedStatsResponse], error)
}

// NewLoadBalancerStatsServiceHandler builds an HTTP handler from the service implementation. It
// returns the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewLoadBalancerStatsServiceHandler(svc LoadBalancerStatsServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/grpc.testing.LoadBalancerStatsService/GetClientStats", connect_go.NewUnaryHandler(
		"/grpc.testing.LoadBalancerStatsService/GetClientStats",
		svc.GetClientStats,
		opts...,
	))
	mux.Handle("/grpc.testing.LoadBalancerStatsService/GetClientAccumulatedStats", connect_go.NewUnaryHandler(
		"/grpc.testing.LoadBalancerStatsService/GetClientAccumulatedStats",
		svc.GetClientAccumulatedStats,
		opts...,
	))
	return "/grpc.testing.LoadBalancerStatsService/", mux
}

// UnimplementedLoadBalancerStatsServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedLoadBalancerStatsServiceHandler struct{}

func (UnimplementedLoadBalancerStatsServiceHandler) GetClientStats(context.Context, *connect_go.Request[testing.LoadBalancerStatsRequest]) (*connect_go.Response[testing.LoadBalancerStatsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.LoadBalancerStatsService.GetClientStats is not implemented"))
}

func (UnimplementedLoadBalancerStatsServiceHandler) GetClientAccumulatedStats(context.Context, *connect_go.Request[testing.LoadBalancerAccumulatedStatsRequest]) (*connect_go.Response[testing.LoadBalancerAccumulatedStatsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.LoadBalancerStatsService.GetClientAccumulatedStats is not implemented"))
}

// XdsUpdateHealthServiceClient is a client for the grpc.testing.XdsUpdateHealthService service.
type XdsUpdateHealthServiceClient interface {
	SetServing(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
	SetNotServing(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
}

// NewXdsUpdateHealthServiceClient constructs a client for the grpc.testing.XdsUpdateHealthService
// service. By default, it uses the Connect protocol with the binary Protobuf Codec, asks for
// gzipped responses, and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply
// the connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewXdsUpdateHealthServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) XdsUpdateHealthServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &xdsUpdateHealthServiceClient{
		setServing: connect_go.NewClient[testing.Empty, testing.Empty](
			httpClient,
			baseURL+"/grpc.testing.XdsUpdateHealthService/SetServing",
			opts...,
		),
		setNotServing: connect_go.NewClient[testing.Empty, testing.Empty](
			httpClient,
			baseURL+"/grpc.testing.XdsUpdateHealthService/SetNotServing",
			opts...,
		),
	}
}

// xdsUpdateHealthServiceClient implements XdsUpdateHealthServiceClient.
type xdsUpdateHealthServiceClient struct {
	setServing    *connect_go.Client[testing.Empty, testing.Empty]
	setNotServing *connect_go.Client[testing.Empty, testing.Empty]
}

// SetServing calls grpc.testing.XdsUpdateHealthService.SetServing.
func (c *xdsUpdateHealthServiceClient) SetServing(ctx context.Context, req *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return c.setServing.CallUnary(ctx, req)
}

// SetNotServing calls grpc.testing.XdsUpdateHealthService.SetNotServing.
func (c *xdsUpdateHealthServiceClient) SetNotServing(ctx context.Context, req *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return c.setNotServing.CallUnary(ctx, req)
}

// XdsUpdateHealthServiceHandler is an implementation of the grpc.testing.XdsUpdateHealthService
// service.
type XdsUpdateHealthServiceHandler interface {
	SetServing(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
	SetNotServing(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
}

// NewXdsUpdateHealthServiceHandler builds an HTTP handler from the service implementation. It
// returns the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewXdsUpdateHealthServiceHandler(svc XdsUpdateHealthServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/grpc.testing.XdsUpdateHealthService/SetServing", connect_go.NewUnaryHandler(
		"/grpc.testing.XdsUpdateHealthService/SetServing",
		svc.SetServing,
		opts...,
	))
	mux.Handle("/grpc.testing.XdsUpdateHealthService/SetNotServing", connect_go.NewUnaryHandler(
		"/grpc.testing.XdsUpdateHealthService/SetNotServing",
		svc.SetNotServing,
		opts...,
	))
	return "/grpc.testing.XdsUpdateHealthService/", mux
}

// UnimplementedXdsUpdateHealthServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedXdsUpdateHealthServiceHandler struct{}

func (UnimplementedXdsUpdateHealthServiceHandler) SetServing(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.XdsUpdateHealthService.SetServing is not implemented"))
}

func (UnimplementedXdsUpdateHealthServiceHandler) SetNotServing(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.XdsUpdateHealthService.SetNotServing is not implemented"))
}

// XdsUpdateClientConfigureServiceClient is a client for the
// grpc.testing.XdsUpdateClientConfigureService service.
type XdsUpdateClientConfigureServiceClient interface {
	// Update the tes client's configuration.
	Configure(context.Context, *connect_go.Request[testing.ClientConfigureRequest]) (*connect_go.Response[testing.ClientConfigureResponse], error)
}

// NewXdsUpdateClientConfigureServiceClient constructs a client for the
// grpc.testing.XdsUpdateClientConfigureService service. By default, it uses the Connect protocol
// with the binary Protobuf Codec, asks for gzipped responses, and sends uncompressed requests. To
// use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or connect.WithGRPCWeb()
// options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewXdsUpdateClientConfigureServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) XdsUpdateClientConfigureServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &xdsUpdateClientConfigureServiceClient{
		configure: connect_go.NewClient[testing.ClientConfigureRequest, testing.ClientConfigureResponse](
			httpClient,
			baseURL+"/grpc.testing.XdsUpdateClientConfigureService/Configure",
			opts...,
		),
	}
}

// xdsUpdateClientConfigureServiceClient implements XdsUpdateClientConfigureServiceClient.
type xdsUpdateClientConfigureServiceClient struct {
	configure *connect_go.Client[testing.ClientConfigureRequest, testing.ClientConfigureResponse]
}

// Configure calls grpc.testing.XdsUpdateClientConfigureService.Configure.
func (c *xdsUpdateClientConfigureServiceClient) Configure(ctx context.Context, req *connect_go.Request[testing.ClientConfigureRequest]) (*connect_go.Response[testing.ClientConfigureResponse], error) {
	return c.configure.CallUnary(ctx, req)
}

// XdsUpdateClientConfigureServiceHandler is an implementation of the
// grpc.testing.XdsUpdateClientConfigureService service.
type XdsUpdateClientConfigureServiceHandler interface {
	// Update the tes client's configuration.
	Configure(context.Context, *connect_go.Request[testing.ClientConfigureRequest]) (*connect_go.Response[testing.ClientConfigureResponse], error)
}

// NewXdsUpdateClientConfigureServiceHandler builds an HTTP handler from the service implementation.
// It returns the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewXdsUpdateClientConfigureServiceHandler(svc XdsUpdateClientConfigureServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/grpc.testing.XdsUpdateClientConfigureService/Configure", connect_go.NewUnaryHandler(
		"/grpc.testing.XdsUpdateClientConfigureService/Configure",
		svc.Configure,
		opts...,
	))
	return "/grpc.testing.XdsUpdateClientConfigureService/", mux
}

// UnimplementedXdsUpdateClientConfigureServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedXdsUpdateClientConfigureServiceHandler struct{}

func (UnimplementedXdsUpdateClientConfigureServiceHandler) Configure(context.Context, *connect_go.Request[testing.ClientConfigureRequest]) (*connect_go.Response[testing.ClientConfigureResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.XdsUpdateClientConfigureService.Configure is not implemented"))
}
