// Copyright 2022 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: grpc/testing/test.proto

package testingconnect

import (
	context "context"
	errors "errors"
	testing "github.com/bufbuild/connect-crosstest/internal/gen/proto/go/grpc/testing"
	connect_go "github.com/bufbuild/connect-go"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion1_7_0

const (
	// TestServiceName is the fully-qualified name of the TestService service.
	TestServiceName = "grpc.testing.TestService"
	// UnimplementedServiceName is the fully-qualified name of the UnimplementedService service.
	UnimplementedServiceName = "grpc.testing.UnimplementedService"
	// ReconnectServiceName is the fully-qualified name of the ReconnectService service.
	ReconnectServiceName = "grpc.testing.ReconnectService"
	// LoadBalancerStatsServiceName is the fully-qualified name of the LoadBalancerStatsService service.
	LoadBalancerStatsServiceName = "grpc.testing.LoadBalancerStatsService"
	// XdsUpdateHealthServiceName is the fully-qualified name of the XdsUpdateHealthService service.
	XdsUpdateHealthServiceName = "grpc.testing.XdsUpdateHealthService"
	// XdsUpdateClientConfigureServiceName is the fully-qualified name of the
	// XdsUpdateClientConfigureService service.
	XdsUpdateClientConfigureServiceName = "grpc.testing.XdsUpdateClientConfigureService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// TestServiceEmptyCallProcedure is the fully-qualified name of the TestService's EmptyCall RPC.
	TestServiceEmptyCallProcedure = "/grpc.testing.TestService/EmptyCall"
	// TestServiceUnaryCallProcedure is the fully-qualified name of the TestService's UnaryCall RPC.
	TestServiceUnaryCallProcedure = "/grpc.testing.TestService/UnaryCall"
	// TestServiceFailUnaryCallProcedure is the fully-qualified name of the TestService's FailUnaryCall
	// RPC.
	TestServiceFailUnaryCallProcedure = "/grpc.testing.TestService/FailUnaryCall"
	// TestServiceCacheableUnaryCallProcedure is the fully-qualified name of the TestService's
	// CacheableUnaryCall RPC.
	TestServiceCacheableUnaryCallProcedure = "/grpc.testing.TestService/CacheableUnaryCall"
	// TestServiceCacheableStreamingOutputCallProcedure is the fully-qualified name of the TestService's
	// CacheableStreamingOutputCall RPC.
	TestServiceCacheableStreamingOutputCallProcedure = "/grpc.testing.TestService/CacheableStreamingOutputCall"
	// TestServiceStreamingOutputCallProcedure is the fully-qualified name of the TestService's
	// StreamingOutputCall RPC.
	TestServiceStreamingOutputCallProcedure = "/grpc.testing.TestService/StreamingOutputCall"
	// TestServiceFailStreamingOutputCallProcedure is the fully-qualified name of the TestService's
	// FailStreamingOutputCall RPC.
	TestServiceFailStreamingOutputCallProcedure = "/grpc.testing.TestService/FailStreamingOutputCall"
	// TestServiceStreamingInputCallProcedure is the fully-qualified name of the TestService's
	// StreamingInputCall RPC.
	TestServiceStreamingInputCallProcedure = "/grpc.testing.TestService/StreamingInputCall"
	// TestServiceFullDuplexCallProcedure is the fully-qualified name of the TestService's
	// FullDuplexCall RPC.
	TestServiceFullDuplexCallProcedure = "/grpc.testing.TestService/FullDuplexCall"
	// TestServiceHalfDuplexCallProcedure is the fully-qualified name of the TestService's
	// HalfDuplexCall RPC.
	TestServiceHalfDuplexCallProcedure = "/grpc.testing.TestService/HalfDuplexCall"
	// TestServiceUnimplementedCallProcedure is the fully-qualified name of the TestService's
	// UnimplementedCall RPC.
	TestServiceUnimplementedCallProcedure = "/grpc.testing.TestService/UnimplementedCall"
	// TestServiceUnimplementedStreamingOutputCallProcedure is the fully-qualified name of the
	// TestService's UnimplementedStreamingOutputCall RPC.
	TestServiceUnimplementedStreamingOutputCallProcedure = "/grpc.testing.TestService/UnimplementedStreamingOutputCall"
	// UnimplementedServiceUnimplementedCallProcedure is the fully-qualified name of the
	// UnimplementedService's UnimplementedCall RPC.
	UnimplementedServiceUnimplementedCallProcedure = "/grpc.testing.UnimplementedService/UnimplementedCall"
	// UnimplementedServiceUnimplementedStreamingOutputCallProcedure is the fully-qualified name of the
	// UnimplementedService's UnimplementedStreamingOutputCall RPC.
	UnimplementedServiceUnimplementedStreamingOutputCallProcedure = "/grpc.testing.UnimplementedService/UnimplementedStreamingOutputCall"
	// ReconnectServiceStartProcedure is the fully-qualified name of the ReconnectService's Start RPC.
	ReconnectServiceStartProcedure = "/grpc.testing.ReconnectService/Start"
	// ReconnectServiceStopProcedure is the fully-qualified name of the ReconnectService's Stop RPC.
	ReconnectServiceStopProcedure = "/grpc.testing.ReconnectService/Stop"
	// LoadBalancerStatsServiceGetClientStatsProcedure is the fully-qualified name of the
	// LoadBalancerStatsService's GetClientStats RPC.
	LoadBalancerStatsServiceGetClientStatsProcedure = "/grpc.testing.LoadBalancerStatsService/GetClientStats"
	// LoadBalancerStatsServiceGetClientAccumulatedStatsProcedure is the fully-qualified name of the
	// LoadBalancerStatsService's GetClientAccumulatedStats RPC.
	LoadBalancerStatsServiceGetClientAccumulatedStatsProcedure = "/grpc.testing.LoadBalancerStatsService/GetClientAccumulatedStats"
	// XdsUpdateHealthServiceSetServingProcedure is the fully-qualified name of the
	// XdsUpdateHealthService's SetServing RPC.
	XdsUpdateHealthServiceSetServingProcedure = "/grpc.testing.XdsUpdateHealthService/SetServing"
	// XdsUpdateHealthServiceSetNotServingProcedure is the fully-qualified name of the
	// XdsUpdateHealthService's SetNotServing RPC.
	XdsUpdateHealthServiceSetNotServingProcedure = "/grpc.testing.XdsUpdateHealthService/SetNotServing"
	// XdsUpdateClientConfigureServiceConfigureProcedure is the fully-qualified name of the
	// XdsUpdateClientConfigureService's Configure RPC.
	XdsUpdateClientConfigureServiceConfigureProcedure = "/grpc.testing.XdsUpdateClientConfigureService/Configure"
)

// TestServiceClient is a client for the grpc.testing.TestService service.
type TestServiceClient interface {
	// One empty request followed by one empty response.
	EmptyCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
	// One request followed by one response.
	UnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error)
	// One request followed by one response. This RPC always fails.
	FailUnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error)
	// One request followed by one response. Response has cache control
	// headers set such that a caching HTTP proxy (such as GFE) can
	// satisfy subsequent requests.
	CacheableUnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error)
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	CacheableStreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest]) (*connect_go.ServerStreamForClient[testing.StreamingOutputCallResponse], error)
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	StreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest]) (*connect_go.ServerStreamForClient[testing.StreamingOutputCallResponse], error)
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	// This RPC always responds with an error status.
	FailStreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest]) (*connect_go.ServerStreamForClient[testing.StreamingOutputCallResponse], error)
	// A sequence of requests followed by one response (streamed upload).
	// The server returns the aggregated size of client payload as the result.
	StreamingInputCall(context.Context) *connect_go.ClientStreamForClient[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse]
	// A sequence of requests with each request served by the server immediately.
	// As one request could lead to multiple responses, this interface
	// demonstrates the idea of full duplexing.
	FullDuplexCall(context.Context) *connect_go.BidiStreamForClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client requests and then serves them in order. A
	// stream of responses are returned to the client when the server starts with
	// first request.
	HalfDuplexCall(context.Context) *connect_go.BidiStreamForClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented methods.
	UnimplementedCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented streaming output methods.
	UnimplementedStreamingOutputCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.ServerStreamForClient[testing.Empty], error)
}

// NewTestServiceClient constructs a client for the grpc.testing.TestService service. By default, it
// uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewTestServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) TestServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &testServiceClient{
		emptyCall: connect_go.NewClient[testing.Empty, testing.Empty](
			httpClient,
			baseURL+TestServiceEmptyCallProcedure,
			opts...,
		),
		unaryCall: connect_go.NewClient[testing.SimpleRequest, testing.SimpleResponse](
			httpClient,
			baseURL+TestServiceUnaryCallProcedure,
			opts...,
		),
		failUnaryCall: connect_go.NewClient[testing.SimpleRequest, testing.SimpleResponse](
			httpClient,
			baseURL+TestServiceFailUnaryCallProcedure,
			opts...,
		),
		cacheableUnaryCall: connect_go.NewClient[testing.SimpleRequest, testing.SimpleResponse](
			httpClient,
			baseURL+TestServiceCacheableUnaryCallProcedure,
			connect_go.WithIdempotency(connect_go.IdempotencyNoSideEffects),
			connect_go.WithClientOptions(opts...),
		),
		cacheableStreamingOutputCall: connect_go.NewClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](
			httpClient,
			baseURL+TestServiceCacheableStreamingOutputCallProcedure,
			connect_go.WithIdempotency(connect_go.IdempotencyNoSideEffects),
			connect_go.WithClientOptions(opts...),
		),
		streamingOutputCall: connect_go.NewClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](
			httpClient,
			baseURL+TestServiceStreamingOutputCallProcedure,
			opts...,
		),
		failStreamingOutputCall: connect_go.NewClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](
			httpClient,
			baseURL+TestServiceFailStreamingOutputCallProcedure,
			opts...,
		),
		streamingInputCall: connect_go.NewClient[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse](
			httpClient,
			baseURL+TestServiceStreamingInputCallProcedure,
			opts...,
		),
		fullDuplexCall: connect_go.NewClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](
			httpClient,
			baseURL+TestServiceFullDuplexCallProcedure,
			opts...,
		),
		halfDuplexCall: connect_go.NewClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse](
			httpClient,
			baseURL+TestServiceHalfDuplexCallProcedure,
			opts...,
		),
		unimplementedCall: connect_go.NewClient[testing.Empty, testing.Empty](
			httpClient,
			baseURL+TestServiceUnimplementedCallProcedure,
			opts...,
		),
		unimplementedStreamingOutputCall: connect_go.NewClient[testing.Empty, testing.Empty](
			httpClient,
			baseURL+TestServiceUnimplementedStreamingOutputCallProcedure,
			opts...,
		),
	}
}

// testServiceClient implements TestServiceClient.
type testServiceClient struct {
	emptyCall                        *connect_go.Client[testing.Empty, testing.Empty]
	unaryCall                        *connect_go.Client[testing.SimpleRequest, testing.SimpleResponse]
	failUnaryCall                    *connect_go.Client[testing.SimpleRequest, testing.SimpleResponse]
	cacheableUnaryCall               *connect_go.Client[testing.SimpleRequest, testing.SimpleResponse]
	cacheableStreamingOutputCall     *connect_go.Client[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	streamingOutputCall              *connect_go.Client[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	failStreamingOutputCall          *connect_go.Client[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	streamingInputCall               *connect_go.Client[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse]
	fullDuplexCall                   *connect_go.Client[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	halfDuplexCall                   *connect_go.Client[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]
	unimplementedCall                *connect_go.Client[testing.Empty, testing.Empty]
	unimplementedStreamingOutputCall *connect_go.Client[testing.Empty, testing.Empty]
}

// EmptyCall calls grpc.testing.TestService.EmptyCall.
func (c *testServiceClient) EmptyCall(ctx context.Context, req *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return c.emptyCall.CallUnary(ctx, req)
}

// UnaryCall calls grpc.testing.TestService.UnaryCall.
func (c *testServiceClient) UnaryCall(ctx context.Context, req *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error) {
	return c.unaryCall.CallUnary(ctx, req)
}

// FailUnaryCall calls grpc.testing.TestService.FailUnaryCall.
func (c *testServiceClient) FailUnaryCall(ctx context.Context, req *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error) {
	return c.failUnaryCall.CallUnary(ctx, req)
}

// CacheableUnaryCall calls grpc.testing.TestService.CacheableUnaryCall.
func (c *testServiceClient) CacheableUnaryCall(ctx context.Context, req *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error) {
	return c.cacheableUnaryCall.CallUnary(ctx, req)
}

// CacheableStreamingOutputCall calls grpc.testing.TestService.CacheableStreamingOutputCall.
func (c *testServiceClient) CacheableStreamingOutputCall(ctx context.Context, req *connect_go.Request[testing.StreamingOutputCallRequest]) (*connect_go.ServerStreamForClient[testing.StreamingOutputCallResponse], error) {
	return c.cacheableStreamingOutputCall.CallServerStream(ctx, req)
}

// StreamingOutputCall calls grpc.testing.TestService.StreamingOutputCall.
func (c *testServiceClient) StreamingOutputCall(ctx context.Context, req *connect_go.Request[testing.StreamingOutputCallRequest]) (*connect_go.ServerStreamForClient[testing.StreamingOutputCallResponse], error) {
	return c.streamingOutputCall.CallServerStream(ctx, req)
}

// FailStreamingOutputCall calls grpc.testing.TestService.FailStreamingOutputCall.
func (c *testServiceClient) FailStreamingOutputCall(ctx context.Context, req *connect_go.Request[testing.StreamingOutputCallRequest]) (*connect_go.ServerStreamForClient[testing.StreamingOutputCallResponse], error) {
	return c.failStreamingOutputCall.CallServerStream(ctx, req)
}

// StreamingInputCall calls grpc.testing.TestService.StreamingInputCall.
func (c *testServiceClient) StreamingInputCall(ctx context.Context) *connect_go.ClientStreamForClient[testing.StreamingInputCallRequest, testing.StreamingInputCallResponse] {
	return c.streamingInputCall.CallClientStream(ctx)
}

// FullDuplexCall calls grpc.testing.TestService.FullDuplexCall.
func (c *testServiceClient) FullDuplexCall(ctx context.Context) *connect_go.BidiStreamForClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse] {
	return c.fullDuplexCall.CallBidiStream(ctx)
}

// HalfDuplexCall calls grpc.testing.TestService.HalfDuplexCall.
func (c *testServiceClient) HalfDuplexCall(ctx context.Context) *connect_go.BidiStreamForClient[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse] {
	return c.halfDuplexCall.CallBidiStream(ctx)
}

// UnimplementedCall calls grpc.testing.TestService.UnimplementedCall.
func (c *testServiceClient) UnimplementedCall(ctx context.Context, req *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return c.unimplementedCall.CallUnary(ctx, req)
}

// UnimplementedStreamingOutputCall calls grpc.testing.TestService.UnimplementedStreamingOutputCall.
func (c *testServiceClient) UnimplementedStreamingOutputCall(ctx context.Context, req *connect_go.Request[testing.Empty]) (*connect_go.ServerStreamForClient[testing.Empty], error) {
	return c.unimplementedStreamingOutputCall.CallServerStream(ctx, req)
}

// TestServiceHandler is an implementation of the grpc.testing.TestService service.
type TestServiceHandler interface {
	// One empty request followed by one empty response.
	EmptyCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
	// One request followed by one response.
	UnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error)
	// One request followed by one response. This RPC always fails.
	FailUnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error)
	// One request followed by one response. Response has cache control
	// headers set such that a caching HTTP proxy (such as GFE) can
	// satisfy subsequent requests.
	CacheableUnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error)
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	CacheableStreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest], *connect_go.ServerStream[testing.StreamingOutputCallResponse]) error
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	StreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest], *connect_go.ServerStream[testing.StreamingOutputCallResponse]) error
	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	// This RPC always responds with an error status.
	FailStreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest], *connect_go.ServerStream[testing.StreamingOutputCallResponse]) error
	// A sequence of requests followed by one response (streamed upload).
	// The server returns the aggregated size of client payload as the result.
	StreamingInputCall(context.Context, *connect_go.ClientStream[testing.StreamingInputCallRequest]) (*connect_go.Response[testing.StreamingInputCallResponse], error)
	// A sequence of requests with each request served by the server immediately.
	// As one request could lead to multiple responses, this interface
	// demonstrates the idea of full duplexing.
	FullDuplexCall(context.Context, *connect_go.BidiStream[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error
	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client requests and then serves them in order. A
	// stream of responses are returned to the client when the server starts with
	// first request.
	HalfDuplexCall(context.Context, *connect_go.BidiStream[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error
	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented methods.
	UnimplementedCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented streaming output methods.
	UnimplementedStreamingOutputCall(context.Context, *connect_go.Request[testing.Empty], *connect_go.ServerStream[testing.Empty]) error
}

// NewTestServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewTestServiceHandler(svc TestServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle(TestServiceEmptyCallProcedure, connect_go.NewUnaryHandler(
		TestServiceEmptyCallProcedure,
		svc.EmptyCall,
		opts...,
	))
	mux.Handle(TestServiceUnaryCallProcedure, connect_go.NewUnaryHandler(
		TestServiceUnaryCallProcedure,
		svc.UnaryCall,
		opts...,
	))
	mux.Handle(TestServiceFailUnaryCallProcedure, connect_go.NewUnaryHandler(
		TestServiceFailUnaryCallProcedure,
		svc.FailUnaryCall,
		opts...,
	))
	mux.Handle(TestServiceCacheableUnaryCallProcedure, connect_go.NewUnaryHandler(
		TestServiceCacheableUnaryCallProcedure,
		svc.CacheableUnaryCall,
		connect_go.WithIdempotency(connect_go.IdempotencyNoSideEffects),
		connect_go.WithHandlerOptions(opts...),
	))
	mux.Handle(TestServiceCacheableStreamingOutputCallProcedure, connect_go.NewServerStreamHandler(
		TestServiceCacheableStreamingOutputCallProcedure,
		svc.CacheableStreamingOutputCall,
		connect_go.WithIdempotency(connect_go.IdempotencyNoSideEffects),
		connect_go.WithHandlerOptions(opts...),
	))
	mux.Handle(TestServiceStreamingOutputCallProcedure, connect_go.NewServerStreamHandler(
		TestServiceStreamingOutputCallProcedure,
		svc.StreamingOutputCall,
		opts...,
	))
	mux.Handle(TestServiceFailStreamingOutputCallProcedure, connect_go.NewServerStreamHandler(
		TestServiceFailStreamingOutputCallProcedure,
		svc.FailStreamingOutputCall,
		opts...,
	))
	mux.Handle(TestServiceStreamingInputCallProcedure, connect_go.NewClientStreamHandler(
		TestServiceStreamingInputCallProcedure,
		svc.StreamingInputCall,
		opts...,
	))
	mux.Handle(TestServiceFullDuplexCallProcedure, connect_go.NewBidiStreamHandler(
		TestServiceFullDuplexCallProcedure,
		svc.FullDuplexCall,
		opts...,
	))
	mux.Handle(TestServiceHalfDuplexCallProcedure, connect_go.NewBidiStreamHandler(
		TestServiceHalfDuplexCallProcedure,
		svc.HalfDuplexCall,
		opts...,
	))
	mux.Handle(TestServiceUnimplementedCallProcedure, connect_go.NewUnaryHandler(
		TestServiceUnimplementedCallProcedure,
		svc.UnimplementedCall,
		opts...,
	))
	mux.Handle(TestServiceUnimplementedStreamingOutputCallProcedure, connect_go.NewServerStreamHandler(
		TestServiceUnimplementedStreamingOutputCallProcedure,
		svc.UnimplementedStreamingOutputCall,
		opts...,
	))
	return "/grpc.testing.TestService/", mux
}

// UnimplementedTestServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedTestServiceHandler struct{}

func (UnimplementedTestServiceHandler) EmptyCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.EmptyCall is not implemented"))
}

func (UnimplementedTestServiceHandler) UnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.UnaryCall is not implemented"))
}

func (UnimplementedTestServiceHandler) FailUnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.FailUnaryCall is not implemented"))
}

func (UnimplementedTestServiceHandler) CacheableUnaryCall(context.Context, *connect_go.Request[testing.SimpleRequest]) (*connect_go.Response[testing.SimpleResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.CacheableUnaryCall is not implemented"))
}

func (UnimplementedTestServiceHandler) CacheableStreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest], *connect_go.ServerStream[testing.StreamingOutputCallResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.CacheableStreamingOutputCall is not implemented"))
}

func (UnimplementedTestServiceHandler) StreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest], *connect_go.ServerStream[testing.StreamingOutputCallResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.StreamingOutputCall is not implemented"))
}

func (UnimplementedTestServiceHandler) FailStreamingOutputCall(context.Context, *connect_go.Request[testing.StreamingOutputCallRequest], *connect_go.ServerStream[testing.StreamingOutputCallResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.FailStreamingOutputCall is not implemented"))
}

func (UnimplementedTestServiceHandler) StreamingInputCall(context.Context, *connect_go.ClientStream[testing.StreamingInputCallRequest]) (*connect_go.Response[testing.StreamingInputCallResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.StreamingInputCall is not implemented"))
}

func (UnimplementedTestServiceHandler) FullDuplexCall(context.Context, *connect_go.BidiStream[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.FullDuplexCall is not implemented"))
}

func (UnimplementedTestServiceHandler) HalfDuplexCall(context.Context, *connect_go.BidiStream[testing.StreamingOutputCallRequest, testing.StreamingOutputCallResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.HalfDuplexCall is not implemented"))
}

func (UnimplementedTestServiceHandler) UnimplementedCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.UnimplementedCall is not implemented"))
}

func (UnimplementedTestServiceHandler) UnimplementedStreamingOutputCall(context.Context, *connect_go.Request[testing.Empty], *connect_go.ServerStream[testing.Empty]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.TestService.UnimplementedStreamingOutputCall is not implemented"))
}

// UnimplementedServiceClient is a client for the grpc.testing.UnimplementedService service.
type UnimplementedServiceClient interface {
	// A call that no server should implement
	UnimplementedCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
	// A call that no server should implement
	UnimplementedStreamingOutputCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.ServerStreamForClient[testing.Empty], error)
}

// NewUnimplementedServiceClient constructs a client for the grpc.testing.UnimplementedService
// service. By default, it uses the Connect protocol with the binary Protobuf Codec, asks for
// gzipped responses, and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply
// the connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewUnimplementedServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) UnimplementedServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &unimplementedServiceClient{
		unimplementedCall: connect_go.NewClient[testing.Empty, testing.Empty](
			httpClient,
			baseURL+UnimplementedServiceUnimplementedCallProcedure,
			opts...,
		),
		unimplementedStreamingOutputCall: connect_go.NewClient[testing.Empty, testing.Empty](
			httpClient,
			baseURL+UnimplementedServiceUnimplementedStreamingOutputCallProcedure,
			opts...,
		),
	}
}

// unimplementedServiceClient implements UnimplementedServiceClient.
type unimplementedServiceClient struct {
	unimplementedCall                *connect_go.Client[testing.Empty, testing.Empty]
	unimplementedStreamingOutputCall *connect_go.Client[testing.Empty, testing.Empty]
}

// UnimplementedCall calls grpc.testing.UnimplementedService.UnimplementedCall.
func (c *unimplementedServiceClient) UnimplementedCall(ctx context.Context, req *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return c.unimplementedCall.CallUnary(ctx, req)
}

// UnimplementedStreamingOutputCall calls
// grpc.testing.UnimplementedService.UnimplementedStreamingOutputCall.
func (c *unimplementedServiceClient) UnimplementedStreamingOutputCall(ctx context.Context, req *connect_go.Request[testing.Empty]) (*connect_go.ServerStreamForClient[testing.Empty], error) {
	return c.unimplementedStreamingOutputCall.CallServerStream(ctx, req)
}

// UnimplementedServiceHandler is an implementation of the grpc.testing.UnimplementedService
// service.
type UnimplementedServiceHandler interface {
	// A call that no server should implement
	UnimplementedCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
	// A call that no server should implement
	UnimplementedStreamingOutputCall(context.Context, *connect_go.Request[testing.Empty], *connect_go.ServerStream[testing.Empty]) error
}

// NewUnimplementedServiceHandler builds an HTTP handler from the service implementation. It returns
// the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewUnimplementedServiceHandler(svc UnimplementedServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle(UnimplementedServiceUnimplementedCallProcedure, connect_go.NewUnaryHandler(
		UnimplementedServiceUnimplementedCallProcedure,
		svc.UnimplementedCall,
		opts...,
	))
	mux.Handle(UnimplementedServiceUnimplementedStreamingOutputCallProcedure, connect_go.NewServerStreamHandler(
		UnimplementedServiceUnimplementedStreamingOutputCallProcedure,
		svc.UnimplementedStreamingOutputCall,
		opts...,
	))
	return "/grpc.testing.UnimplementedService/", mux
}

// UnimplementedUnimplementedServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedUnimplementedServiceHandler struct{}

func (UnimplementedUnimplementedServiceHandler) UnimplementedCall(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.UnimplementedService.UnimplementedCall is not implemented"))
}

func (UnimplementedUnimplementedServiceHandler) UnimplementedStreamingOutputCall(context.Context, *connect_go.Request[testing.Empty], *connect_go.ServerStream[testing.Empty]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.UnimplementedService.UnimplementedStreamingOutputCall is not implemented"))
}

// ReconnectServiceClient is a client for the grpc.testing.ReconnectService service.
type ReconnectServiceClient interface {
	Start(context.Context, *connect_go.Request[testing.ReconnectParams]) (*connect_go.Response[testing.Empty], error)
	Stop(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.ReconnectInfo], error)
}

// NewReconnectServiceClient constructs a client for the grpc.testing.ReconnectService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewReconnectServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) ReconnectServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &reconnectServiceClient{
		start: connect_go.NewClient[testing.ReconnectParams, testing.Empty](
			httpClient,
			baseURL+ReconnectServiceStartProcedure,
			opts...,
		),
		stop: connect_go.NewClient[testing.Empty, testing.ReconnectInfo](
			httpClient,
			baseURL+ReconnectServiceStopProcedure,
			opts...,
		),
	}
}

// reconnectServiceClient implements ReconnectServiceClient.
type reconnectServiceClient struct {
	start *connect_go.Client[testing.ReconnectParams, testing.Empty]
	stop  *connect_go.Client[testing.Empty, testing.ReconnectInfo]
}

// Start calls grpc.testing.ReconnectService.Start.
func (c *reconnectServiceClient) Start(ctx context.Context, req *connect_go.Request[testing.ReconnectParams]) (*connect_go.Response[testing.Empty], error) {
	return c.start.CallUnary(ctx, req)
}

// Stop calls grpc.testing.ReconnectService.Stop.
func (c *reconnectServiceClient) Stop(ctx context.Context, req *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.ReconnectInfo], error) {
	return c.stop.CallUnary(ctx, req)
}

// ReconnectServiceHandler is an implementation of the grpc.testing.ReconnectService service.
type ReconnectServiceHandler interface {
	Start(context.Context, *connect_go.Request[testing.ReconnectParams]) (*connect_go.Response[testing.Empty], error)
	Stop(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.ReconnectInfo], error)
}

// NewReconnectServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewReconnectServiceHandler(svc ReconnectServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle(ReconnectServiceStartProcedure, connect_go.NewUnaryHandler(
		ReconnectServiceStartProcedure,
		svc.Start,
		opts...,
	))
	mux.Handle(ReconnectServiceStopProcedure, connect_go.NewUnaryHandler(
		ReconnectServiceStopProcedure,
		svc.Stop,
		opts...,
	))
	return "/grpc.testing.ReconnectService/", mux
}

// UnimplementedReconnectServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedReconnectServiceHandler struct{}

func (UnimplementedReconnectServiceHandler) Start(context.Context, *connect_go.Request[testing.ReconnectParams]) (*connect_go.Response[testing.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.ReconnectService.Start is not implemented"))
}

func (UnimplementedReconnectServiceHandler) Stop(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.ReconnectInfo], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.ReconnectService.Stop is not implemented"))
}

// LoadBalancerStatsServiceClient is a client for the grpc.testing.LoadBalancerStatsService service.
type LoadBalancerStatsServiceClient interface {
	// Gets the backend distribution for RPCs sent by a test client.
	GetClientStats(context.Context, *connect_go.Request[testing.LoadBalancerStatsRequest]) (*connect_go.Response[testing.LoadBalancerStatsResponse], error)
	// Gets the accumulated stats for RPCs sent by a test client.
	GetClientAccumulatedStats(context.Context, *connect_go.Request[testing.LoadBalancerAccumulatedStatsRequest]) (*connect_go.Response[testing.LoadBalancerAccumulatedStatsResponse], error)
}

// NewLoadBalancerStatsServiceClient constructs a client for the
// grpc.testing.LoadBalancerStatsService service. By default, it uses the Connect protocol with the
// binary Protobuf Codec, asks for gzipped responses, and sends uncompressed requests. To use the
// gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewLoadBalancerStatsServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) LoadBalancerStatsServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &loadBalancerStatsServiceClient{
		getClientStats: connect_go.NewClient[testing.LoadBalancerStatsRequest, testing.LoadBalancerStatsResponse](
			httpClient,
			baseURL+LoadBalancerStatsServiceGetClientStatsProcedure,
			opts...,
		),
		getClientAccumulatedStats: connect_go.NewClient[testing.LoadBalancerAccumulatedStatsRequest, testing.LoadBalancerAccumulatedStatsResponse](
			httpClient,
			baseURL+LoadBalancerStatsServiceGetClientAccumulatedStatsProcedure,
			opts...,
		),
	}
}

// loadBalancerStatsServiceClient implements LoadBalancerStatsServiceClient.
type loadBalancerStatsServiceClient struct {
	getClientStats            *connect_go.Client[testing.LoadBalancerStatsRequest, testing.LoadBalancerStatsResponse]
	getClientAccumulatedStats *connect_go.Client[testing.LoadBalancerAccumulatedStatsRequest, testing.LoadBalancerAccumulatedStatsResponse]
}

// GetClientStats calls grpc.testing.LoadBalancerStatsService.GetClientStats.
func (c *loadBalancerStatsServiceClient) GetClientStats(ctx context.Context, req *connect_go.Request[testing.LoadBalancerStatsRequest]) (*connect_go.Response[testing.LoadBalancerStatsResponse], error) {
	return c.getClientStats.CallUnary(ctx, req)
}

// GetClientAccumulatedStats calls grpc.testing.LoadBalancerStatsService.GetClientAccumulatedStats.
func (c *loadBalancerStatsServiceClient) GetClientAccumulatedStats(ctx context.Context, req *connect_go.Request[testing.LoadBalancerAccumulatedStatsRequest]) (*connect_go.Response[testing.LoadBalancerAccumulatedStatsResponse], error) {
	return c.getClientAccumulatedStats.CallUnary(ctx, req)
}

// LoadBalancerStatsServiceHandler is an implementation of the grpc.testing.LoadBalancerStatsService
// service.
type LoadBalancerStatsServiceHandler interface {
	// Gets the backend distribution for RPCs sent by a test client.
	GetClientStats(context.Context, *connect_go.Request[testing.LoadBalancerStatsRequest]) (*connect_go.Response[testing.LoadBalancerStatsResponse], error)
	// Gets the accumulated stats for RPCs sent by a test client.
	GetClientAccumulatedStats(context.Context, *connect_go.Request[testing.LoadBalancerAccumulatedStatsRequest]) (*connect_go.Response[testing.LoadBalancerAccumulatedStatsResponse], error)
}

// NewLoadBalancerStatsServiceHandler builds an HTTP handler from the service implementation. It
// returns the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewLoadBalancerStatsServiceHandler(svc LoadBalancerStatsServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle(LoadBalancerStatsServiceGetClientStatsProcedure, connect_go.NewUnaryHandler(
		LoadBalancerStatsServiceGetClientStatsProcedure,
		svc.GetClientStats,
		opts...,
	))
	mux.Handle(LoadBalancerStatsServiceGetClientAccumulatedStatsProcedure, connect_go.NewUnaryHandler(
		LoadBalancerStatsServiceGetClientAccumulatedStatsProcedure,
		svc.GetClientAccumulatedStats,
		opts...,
	))
	return "/grpc.testing.LoadBalancerStatsService/", mux
}

// UnimplementedLoadBalancerStatsServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedLoadBalancerStatsServiceHandler struct{}

func (UnimplementedLoadBalancerStatsServiceHandler) GetClientStats(context.Context, *connect_go.Request[testing.LoadBalancerStatsRequest]) (*connect_go.Response[testing.LoadBalancerStatsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.LoadBalancerStatsService.GetClientStats is not implemented"))
}

func (UnimplementedLoadBalancerStatsServiceHandler) GetClientAccumulatedStats(context.Context, *connect_go.Request[testing.LoadBalancerAccumulatedStatsRequest]) (*connect_go.Response[testing.LoadBalancerAccumulatedStatsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.LoadBalancerStatsService.GetClientAccumulatedStats is not implemented"))
}

// XdsUpdateHealthServiceClient is a client for the grpc.testing.XdsUpdateHealthService service.
type XdsUpdateHealthServiceClient interface {
	SetServing(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
	SetNotServing(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
}

// NewXdsUpdateHealthServiceClient constructs a client for the grpc.testing.XdsUpdateHealthService
// service. By default, it uses the Connect protocol with the binary Protobuf Codec, asks for
// gzipped responses, and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply
// the connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewXdsUpdateHealthServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) XdsUpdateHealthServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &xdsUpdateHealthServiceClient{
		setServing: connect_go.NewClient[testing.Empty, testing.Empty](
			httpClient,
			baseURL+XdsUpdateHealthServiceSetServingProcedure,
			opts...,
		),
		setNotServing: connect_go.NewClient[testing.Empty, testing.Empty](
			httpClient,
			baseURL+XdsUpdateHealthServiceSetNotServingProcedure,
			opts...,
		),
	}
}

// xdsUpdateHealthServiceClient implements XdsUpdateHealthServiceClient.
type xdsUpdateHealthServiceClient struct {
	setServing    *connect_go.Client[testing.Empty, testing.Empty]
	setNotServing *connect_go.Client[testing.Empty, testing.Empty]
}

// SetServing calls grpc.testing.XdsUpdateHealthService.SetServing.
func (c *xdsUpdateHealthServiceClient) SetServing(ctx context.Context, req *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return c.setServing.CallUnary(ctx, req)
}

// SetNotServing calls grpc.testing.XdsUpdateHealthService.SetNotServing.
func (c *xdsUpdateHealthServiceClient) SetNotServing(ctx context.Context, req *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return c.setNotServing.CallUnary(ctx, req)
}

// XdsUpdateHealthServiceHandler is an implementation of the grpc.testing.XdsUpdateHealthService
// service.
type XdsUpdateHealthServiceHandler interface {
	SetServing(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
	SetNotServing(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error)
}

// NewXdsUpdateHealthServiceHandler builds an HTTP handler from the service implementation. It
// returns the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewXdsUpdateHealthServiceHandler(svc XdsUpdateHealthServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle(XdsUpdateHealthServiceSetServingProcedure, connect_go.NewUnaryHandler(
		XdsUpdateHealthServiceSetServingProcedure,
		svc.SetServing,
		opts...,
	))
	mux.Handle(XdsUpdateHealthServiceSetNotServingProcedure, connect_go.NewUnaryHandler(
		XdsUpdateHealthServiceSetNotServingProcedure,
		svc.SetNotServing,
		opts...,
	))
	return "/grpc.testing.XdsUpdateHealthService/", mux
}

// UnimplementedXdsUpdateHealthServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedXdsUpdateHealthServiceHandler struct{}

func (UnimplementedXdsUpdateHealthServiceHandler) SetServing(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.XdsUpdateHealthService.SetServing is not implemented"))
}

func (UnimplementedXdsUpdateHealthServiceHandler) SetNotServing(context.Context, *connect_go.Request[testing.Empty]) (*connect_go.Response[testing.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.XdsUpdateHealthService.SetNotServing is not implemented"))
}

// XdsUpdateClientConfigureServiceClient is a client for the
// grpc.testing.XdsUpdateClientConfigureService service.
type XdsUpdateClientConfigureServiceClient interface {
	// Update the tes client's configuration.
	Configure(context.Context, *connect_go.Request[testing.ClientConfigureRequest]) (*connect_go.Response[testing.ClientConfigureResponse], error)
}

// NewXdsUpdateClientConfigureServiceClient constructs a client for the
// grpc.testing.XdsUpdateClientConfigureService service. By default, it uses the Connect protocol
// with the binary Protobuf Codec, asks for gzipped responses, and sends uncompressed requests. To
// use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or connect.WithGRPCWeb()
// options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewXdsUpdateClientConfigureServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) XdsUpdateClientConfigureServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &xdsUpdateClientConfigureServiceClient{
		configure: connect_go.NewClient[testing.ClientConfigureRequest, testing.ClientConfigureResponse](
			httpClient,
			baseURL+XdsUpdateClientConfigureServiceConfigureProcedure,
			opts...,
		),
	}
}

// xdsUpdateClientConfigureServiceClient implements XdsUpdateClientConfigureServiceClient.
type xdsUpdateClientConfigureServiceClient struct {
	configure *connect_go.Client[testing.ClientConfigureRequest, testing.ClientConfigureResponse]
}

// Configure calls grpc.testing.XdsUpdateClientConfigureService.Configure.
func (c *xdsUpdateClientConfigureServiceClient) Configure(ctx context.Context, req *connect_go.Request[testing.ClientConfigureRequest]) (*connect_go.Response[testing.ClientConfigureResponse], error) {
	return c.configure.CallUnary(ctx, req)
}

// XdsUpdateClientConfigureServiceHandler is an implementation of the
// grpc.testing.XdsUpdateClientConfigureService service.
type XdsUpdateClientConfigureServiceHandler interface {
	// Update the tes client's configuration.
	Configure(context.Context, *connect_go.Request[testing.ClientConfigureRequest]) (*connect_go.Response[testing.ClientConfigureResponse], error)
}

// NewXdsUpdateClientConfigureServiceHandler builds an HTTP handler from the service implementation.
// It returns the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewXdsUpdateClientConfigureServiceHandler(svc XdsUpdateClientConfigureServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle(XdsUpdateClientConfigureServiceConfigureProcedure, connect_go.NewUnaryHandler(
		XdsUpdateClientConfigureServiceConfigureProcedure,
		svc.Configure,
		opts...,
	))
	return "/grpc.testing.XdsUpdateClientConfigureService/", mux
}

// UnimplementedXdsUpdateClientConfigureServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedXdsUpdateClientConfigureServiceHandler struct{}

func (UnimplementedXdsUpdateClientConfigureServiceHandler) Configure(context.Context, *connect_go.Request[testing.ClientConfigureRequest]) (*connect_go.Response[testing.ClientConfigureResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("grpc.testing.XdsUpdateClientConfigureService.Configure is not implemented"))
}
